"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const np = require("path");
const path_1 = require("./path");
/**
 * 表示一个匹配器。
 */
class Matcher {
    /**
     * 初始化新的匹配器。
     * @param pattern 要添加的匹配模式。
     * @param cwd 模式的根路径。默认当前工作文件夹。
     */
    constructor(pattern, cwd) {
        /**
         * 所有已编译的模式列表。
         */
        this.patterns = [];
        if (pattern != undefined) {
            this.add(pattern, cwd);
        }
    }
    /**
     * 添加一个匹配模式。
     * @param pattern 要添加的匹配模式。
     * @param cwd 模式的根路径。默认当前工作文件夹。
     */
    add(pattern, cwd) {
        if (typeof pattern === "string") {
            if (pattern.charCodeAt(0) === 33 /*!*/) {
                (this.ignoreMatcher || (this.ignoreMatcher = new Matcher())).patterns.push(globToRegExp(pattern.substr(1), np.resolve(cwd || "")));
            }
            else {
                this.patterns.push(globToRegExp(pattern, np.resolve(cwd || "")));
            }
        }
        else if (Array.isArray(pattern)) {
            for (const p of pattern) {
                this.add(p, cwd);
            }
        }
        else if (pattern instanceof RegExp) {
            this.patterns.push({
                base: np.resolve(cwd || ""),
                test(path) {
                    return pattern.test(path_1.relativePath(this.base, path));
                }
            });
        }
        else if (typeof pattern === "function") {
            this.patterns.push({
                base: np.resolve(cwd || ""),
                test: pattern
            });
        }
        else if (pattern instanceof Matcher) {
            this.patterns.push(...pattern.patterns);
            if (pattern.ignoreMatcher) {
                (this.ignoreMatcher || (this.ignoreMatcher = new Matcher())).add(pattern.ignoreMatcher, cwd);
            }
        }
    }
    /**
     * 添加一个忽略模式。
     * @param pattern 要添加的模式。
     * @param cwd 模式的根路径。默认当前工作文件夹。
     */
    addIgnore(pattern, cwd) {
        (this.ignoreMatcher || (this.ignoreMatcher = new Matcher())).add(pattern, cwd);
    }
    /**
     * 测试指定的绝对路径是否符合当前匹配器。
     * @param path 要测试的绝对路径。
     * @return 如果匹配任意一个已添加的模式且未被忽略则返回 true，否则返回 false。
     */
    test(path) {
        for (const pattern of this.patterns) {
            if (pattern.test(path)) {
                if (this.ignoreMatcher && this.ignoreMatcher.test(path)) {
                    return false;
                }
                return true;
            }
        }
        // 无匹配器默认认为是全匹配。
        if (!this.patterns.length) {
            if (this.ignoreMatcher && this.ignoreMatcher.test(path)) {
                return false;
            }
            return true;
        }
        return false;
    }
    /**
     * 获取所有模式的公共基路径。
     * @return 返回基路径。如果无法获取获取则返回 null。
     */
    get base() {
        if (!this.patterns.length) {
            return null;
        }
        let result = this.patterns[0].base;
        for (let i = 1; i < this.patterns.length; i++) {
            result = path_1.commonDir(result, this.patterns[i].base);
        }
        return result;
    }
    /**
     * 测试指定的内容是否符合指定的模式。
     * @param value 要测试的内容。
     * @param pattern 要测试的匹配模式。
     * @param cwd 模式的根路径。默认当前工作文件夹。
     * @return 如果匹配则返回 true，否则返回 false。
     */
    static test(value, pattern, cwd) {
        return new Matcher(pattern, cwd).test(np.resolve(value));
    }
}
exports.Matcher = Matcher;
exports.default = Matcher;
const compiledPatterns = { __proto__: null };
const escapedSep = escapeRegExp(np.sep);
/**
 * 将指定的通配符转为等价的正则表达式。
 * @param pattern 要处理的通配符。
 * @param cwd 模式的根路径。
 * @return 返回已编译的正则表达式。
 */
function globToRegExp(pattern, cwd) {
    const cacheKey = `${cwd}>${pattern}`;
    const compiledPattern = compiledPatterns[cacheKey];
    if (compiledPattern) {
        return compiledPattern;
    }
    // 处理绝对路径。
    if (np.isAbsolute(pattern)) {
        cwd = "";
        if (np.sep === "\\") {
            pattern = pattern.replace(/\\/g, "/");
        }
    }
    // 格式化通配符。
    let glob = np.posix.normalize(pattern);
    if (glob.length <= 2 && (glob === "./" || glob === ".")) {
        glob = "";
    }
    // 判断是否存在 /。
    const hasSlash = !glob || pattern.lastIndexOf("/", pattern.length - 2) >= 0;
    const hasSlashPostfix = pattern.charCodeAt(pattern.length - 1) === 47 /*/*/;
    // 预处理 ../ 前缀。
    const match = /^(?:\.\.\/)+/.exec(glob);
    if (match) {
        cwd = np.join(cwd, match[0]).slice(0, -1);
        glob = glob.substr(match[0].length);
    }
    // 转为正则表达式。
    const regex = `${hasSlash ? `^${escapeRegExp(cwd)}${cwd && !cwd.endsWith(np.sep) ? escapedSep : ""}` : `(?:^|${escapedSep})`}${glob.replace(/\\.|\[(?:\\.|[^\\\]])+\]|\*\*\/?|[*?\-+.^|\\{}()[\]/]/g, (all, index) => {
        switch (all.charCodeAt(0)) {
            case 47 /*/*/:
                return escapedSep;
            case 42 /***/:
                return all.length > 2 ? `(.*${escapedSep})?` : all.length > 1 ? "(.*)" : `([^${escapedSep}]*)`;
            case 63 /*?*/:
                return `([^${escapedSep}])`;
            case 92 /*\*/:
                return index === pattern.length - 1 ? " " : escapeRegExp(all.charAt(1));
            case 91 /*[*/:
                if (all.length > 2) {
                    index = all.charCodeAt(1) === 94 /*^*/ ? 2 : 1;
                    return (index === 1 ? "[" : "[^") + escapeRegExp(all.slice(index, -1)) + "]";
                }
            // fall through
            default:
                return "\\" + all;
        }
    })}${hasSlashPostfix ? "" : `(?:$|${escapedSep})`}`;
    // 计算基路径。
    // 提取 "foo/goo/*.js" 中的 "foo/goo" 部分。
    if (hasSlash) {
        let right;
        const firstGlob = glob.search(/[*?\\]|\[.+\]/);
        if (firstGlob >= 0) {
            right = glob.lastIndexOf("/", firstGlob);
        }
        else {
            right = glob.length;
            if (hasSlashPostfix) {
                right--;
            }
        }
        if (right > 0) {
            cwd = np.join(cwd, glob.substring(0, right));
        }
    }
    // 生成正则表达式。
    const result = compiledPatterns[cacheKey] = new RegExp(regex, np.sep === "\\" ? "i" : "");
    result.base = cwd;
    return result;
}
/**
 * 编码字符串里的正则表达式特殊字符。
 * @param pattern 要处理的通配符。
 * @return 返回处理后的模式字符串。
 */
function escapeRegExp(pattern) {
    return pattern.replace(/[-+.^$?*|\\{}()[\]]/g, "\\$&");
}
