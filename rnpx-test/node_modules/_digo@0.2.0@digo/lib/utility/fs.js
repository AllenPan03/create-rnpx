"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const nfs = require("fs");
const np = require("path");
const crypto_1 = require("./crypto");
function getStat(path, callback, retry = 3) {
    return stat(nfs.stat, nfs.statSync, path, callback, retry);
}
exports.getStat = getStat;
function getStatLink(path, callback, retry = 3) {
    return stat(nfs.lstat, nfs.lstatSync, path, callback, retry);
}
exports.getStatLink = getStatLink;
function stat(asyncFunc, syncFunc, path, callback, retry) {
    if (typeof callback === "function") {
        asyncFunc(path, (error, stats) => {
            if (!error || error.code === "ENOENT" || retry === 0) {
                callback(error, stats);
            }
            else {
                setTimeout(stat, 7, asyncFunc, syncFunc, path, callback, retry - 1);
            }
        });
    }
    else {
        try {
            return syncFunc(path);
        }
        catch (e) {
            if (e.code === "ENOENT" || retry === 0) {
                throw e;
            }
            return stat(asyncFunc, syncFunc, path, callback, retry - 1);
        }
    }
}
function existsDir(path, callback, retry = 3) {
    return exists("isDirectory", path, callback, retry);
}
exports.existsDir = existsDir;
function existsFile(path, callback, retry = 3) {
    return exists("isFile", path, callback, retry);
}
exports.existsFile = existsFile;
function exists(funcName, path, callback, retry) {
    if (typeof callback === "function") {
        getStat(path, (error, stats) => {
            callback(error ? false : stats[funcName]());
        }, retry);
    }
    else {
        try {
            return getStat(path, undefined, retry)[funcName]();
        }
        catch (e) {
            return false;
        }
    }
}
function ensureNewPath(path, callback, startId) {
    const testPath = startId === undefined ? path : `${np.basename(path, np.extname(path))}_${startId}${np.extname(path)}`;
    if (typeof callback === "function") {
        nfs.exists(testPath, exists => {
            if (!exists) {
                callback(testPath);
            }
            else {
                ensureNewPath(path, callback, startId + 1 || 1);
            }
        });
    }
    else {
        if (!nfs.existsSync(testPath)) {
            return testPath;
        }
        return ensureNewPath(path, undefined, startId + 1 || 1);
    }
}
exports.ensureNewPath = ensureNewPath;
/**
 * 创建一个文件夹。
 * @param path 要创建的文件夹路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function createDir(path, callback, retry = 3) {
    if (typeof callback === "function") {
        nfs.mkdir(path, 0o777 & ~process.umask(), error => {
            if (!error) {
                callback(null);
            }
            else if (error.code === "EEXIST") {
                existsDir(path, result => {
                    callback(result ? null : error);
                }, retry);
            }
            else if (retry === 0) {
                callback(error);
            }
            else if (error.code === "ENOENT") {
                ensureParentDir(path, () => {
                    createDir(path, callback, retry - 1);
                }, retry);
            }
            else {
                setTimeout(createDir, 7, path, callback, retry - 1);
            }
        });
    }
    else {
        try {
            nfs.mkdirSync(path, 0o777 & ~process.umask());
        }
        catch (e) {
            if (e.code === "EEXIST") {
                if (existsDir(path, undefined, retry)) {
                    return;
                }
                throw e;
            }
            if (retry === 0) {
                throw e;
            }
            // FIXME: Win32: 如果路径中含非法字符，可能也会导致 ENOENT。
            // http://stackoverflow.com/questions/62771/how-do-i-check-if-a-given-string-is-a-legal-valid-file-name-under-windows/62888
            if (e.code === "ENOENT") {
                try {
                    ensureParentDir(path, undefined, retry);
                }
                catch (e2) {
                }
            }
            createDir(path, undefined, retry - 1);
        }
    }
}
exports.createDir = createDir;
/**
 * 确保已创建指定路径所在的文件夹。
 * @param path 要处理的路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function ensureParentDir(path, callback, retry = 3) {
    createDir(np.dirname(path), callback, retry);
}
exports.ensureParentDir = ensureParentDir;
/**
 * 删除指定的文件夹。
 * @param path 要删除的文件夹路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function deleteDir(path, callback, retry = 3) {
    if (typeof callback === "function") {
        nfs.rmdir(path, error => {
            if (!error || error.code === "ENOENT") {
                callback(null);
            }
            else if (error.code === "ENOTDIR" || retry === 0) {
                callback(error);
            }
            else if (error.code === "ENOTEMPTY" || error.code === "EEXIST") {
                cleanDir(path, () => {
                    deleteDir(path, callback, retry - 1);
                }, retry);
            }
            else {
                setTimeout(deleteDir, 7, path, callback, retry - 1);
            }
        });
    }
    else {
        try {
            nfs.rmdirSync(path);
        }
        catch (e) {
            if (e.code === "ENOENT") {
                return;
            }
            if (e.code === "ENOTDIR" || retry === 0) {
                throw e;
            }
            if (e.code === "ENOTEMPTY" || e.code === "EEXIST") {
                cleanDir(path, undefined, retry);
            }
            deleteDir(path, undefined, retry - 1);
        }
    }
}
exports.deleteDir = deleteDir;
/**
 * 清空指定的文件夹。
 * @param path 要清空的文件夹路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function cleanDir(path, callback, retry = 3) {
    if (typeof callback === "function") {
        readDirIf(path, (error, entries) => {
            if (!error) {
                let pending = entries.length;
                if (pending) {
                    const done = (e) => {
                        if (e && !error) {
                            error = e;
                        }
                        if (--pending < 1) {
                            callback(error);
                        }
                    };
                    for (const entry of entries) {
                        const child = np.join(path, entry);
                        getStatLink(child, (error, stats) => {
                            if (error) {
                                done(error);
                            }
                            else if (stats.isDirectory()) {
                                deleteDir(child, done, retry);
                            }
                            else {
                                deleteFile(child, done, retry);
                            }
                        }, retry);
                    }
                }
                else {
                    callback(null);
                }
            }
            else {
                callback(error);
            }
        }, retry);
    }
    else {
        let error;
        for (const entry of readDirIf(path, undefined, retry)) {
            const child = np.join(path, entry);
            try {
                if (getStatLink(child, undefined, retry).isDirectory()) {
                    deleteDir(child, undefined, retry);
                }
                else {
                    deleteFile(child, undefined, retry);
                }
            }
            catch (e) {
                if (!error) {
                    error = e;
                }
            }
        }
        if (error) {
            throw error;
        }
    }
}
exports.cleanDir = cleanDir;
/**
 * 如果父文件夹是空文件夹则删除。
 * @param path 文件夹内的文件路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function deleteParentDirIfEmpty(path, callback, retry = 3) {
    const parent = np.dirname(path);
    if (typeof callback === "function") {
        if (parent !== path) {
            nfs.rmdir(parent, error => {
                if (!error) {
                    deleteParentDirIfEmpty(parent, callback, retry);
                }
                else {
                    switch (error.code) {
                        case "ENOTEMPTY":
                        case "ENOENT":
                        case "EEXIST":
                        case "EBUSY":
                            callback(null);
                            break;
                        default:
                            if (retry === 0) {
                                callback(error);
                            }
                            else {
                                setTimeout(deleteParentDirIfEmpty, 7, path, callback, retry - 1);
                            }
                            break;
                    }
                }
            });
        }
        else {
            callback(null);
        }
    }
    else if (parent !== path) {
        try {
            nfs.rmdirSync(parent);
        }
        catch (e) {
            switch (e.code) {
                case "ENOTEMPTY":
                case "ENOENT":
                case "EEXIST":
                case "EBUSY":
                    return;
                default:
                    if (retry === 0) {
                        throw e;
                    }
                    deleteParentDirIfEmpty(path, undefined, retry - 1);
                    return;
            }
        }
        deleteParentDirIfEmpty(parent, undefined, retry);
    }
}
exports.deleteParentDirIfEmpty = deleteParentDirIfEmpty;
/**
 * 删除指定的文件，如果文件不存在则直接返回。
 * @param path 要删除的文件路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function deleteFile(path, callback, retry = 3) {
    if (typeof callback === "function") {
        nfs.unlink(path, error => {
            if (!error || error.code === "ENOENT") {
                callback(null);
            }
            else if (error.code === "EISDIR" || retry === 0) {
                callback(error);
            }
            else {
                setTimeout(deleteFile, 7, path, callback, retry - 1);
            }
        });
    }
    else {
        try {
            nfs.unlinkSync(path);
        }
        catch (e) {
            if (e.code === "ENOENT") {
                return;
            }
            if (e.code === "EISDIR" || retry === 0) {
                throw e;
            }
            deleteFile(path, undefined, retry - 1);
        }
    }
}
exports.deleteFile = deleteFile;
function readDir(path, callback, retry = 3) {
    if (typeof callback === "function") {
        nfs.readdir(path, (error, entries) => {
            if (!error || error.code === "ENOTDIR" || error.code === "ENOENT") {
                callback(error, entries);
                resolve();
            }
            else {
                switch (error.code) {
                    case "EMFILE":
                    case "ENFILE":
                        delay(readDir, [path, callback, retry - 1]);
                        break;
                    default:
                        if (retry === 0) {
                            callback(error, null);
                            resolve();
                        }
                        else {
                            setTimeout(readDir, 7, path, callback, retry - 1);
                        }
                        break;
                }
            }
        });
    }
    else {
        try {
            return nfs.readdirSync(path);
        }
        catch (e) {
            if (e.code === "ENOENT" || e.code === "ENOTDIR" || retry === 0) {
                throw e;
            }
            return readDir(path, undefined, retry - 1);
        }
    }
}
exports.readDir = readDir;
/**
 * 读取文件夹内的所有项，如果文件夹不存在则返回空列表。
 * @param path 要读取的文件夹路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 * @return 返回文件夹内所有项。如果文件夹不存在则返回空数组。如果 *callback* 是函数则不返回。
 */
function readDirIf(path, callback, retry = 3) {
    return readIf(readDir, () => [], path, callback, retry);
}
exports.readDirIf = readDirIf;
/**
 * 深度遍历指定的文件或文件夹并执行回调。
 * @param path 要遍历的文件或文件夹路径。
 * @param options 遍历的选项。
 * @param retry 操作失败后自动重试的次数。
 */
function walk(path, options, retry = 3) {
    if (options.end) {
        let pending = 0;
        const processFileOrDir = (path) => {
            pending++;
            if (options.stats) {
                let cache = options.stats[path];
                if (cache) {
                    if (Array.isArray(cache)) {
                        cache.push(statCallback);
                    }
                    else {
                        statCallback(path, null, cache);
                    }
                }
                else {
                    options.stats[path] = cache = [statCallback];
                    (options.follow ? getStat : getStatLink)(path, (error, stats) => {
                        options.stats[path] = stats;
                        for (const func of cache) {
                            func(path, error, stats);
                        }
                    }, retry);
                }
            }
            else {
                (options.follow ? getStat : getStatLink)(path, (error, stats) => {
                    statCallback(path, error, stats);
                }, retry);
            }
        };
        const statCallback = (path, error, stats) => {
            if (error) {
                options.error && options.error(error);
            }
            else if (stats.isFile()) {
                options.file && options.file(path, stats);
            }
            else if (stats.isDirectory()) {
                if (!options.dir || options.dir(path, stats) !== false) {
                    processDir(path, stats);
                }
            }
            else {
                options.other && options.other(path, stats);
            }
            if (--pending < 1) {
                options.end();
            }
        };
        const processDir = (path, stats) => {
            pending++;
            if (options.entries) {
                let cache = options.entries[path];
                if (cache) {
                    if (typeof cache[0] === "function") {
                        cache.push(readDirCallback);
                    }
                    else {
                        readDirCallback(path, null, stats, cache);
                    }
                }
                else {
                    options.entries[path] = cache = [readDirCallback];
                    readDir(path, (error, entries) => {
                        options.entries[path] = entries;
                        for (const func of cache) {
                            func(path, error, stats, entries);
                        }
                    }, retry);
                }
            }
            else {
                readDir(path, (error, entries) => {
                    readDirCallback(path, error, stats, entries);
                }, retry);
            }
        };
        const readDirCallback = (path, error, stats, entries) => {
            if (error) {
                options.error && options.error(error);
            }
            else {
                if (!options.walk || options.walk(path, stats, entries) !== false) {
                    for (const entry of entries) {
                        processFileOrDir(np.join(path, entry));
                    }
                }
            }
            if (--pending < 1) {
                options.end();
            }
        };
        processFileOrDir(path);
    }
    else {
        const processFileOrDir = (path) => {
            let stats;
            try {
                stats = getCache(options.stats, path) || getStat(path, undefined, retry);
            }
            catch (e) {
                return options.error && options.error(e);
            }
            if (stats.isFile()) {
                options.file && options.file(path, stats);
            }
            else if (stats.isDirectory()) {
                if (!options.dir || options.dir(path, stats) !== false) {
                    processDir(path, stats);
                }
            }
            else {
                options.other && options.other(path, stats);
            }
        };
        const processDir = (path, stats) => {
            let entries;
            try {
                entries = getCache(options.entries, path) || readDir(path, undefined, retry);
            }
            catch (e) {
                return options.error && options.error(e);
            }
            if (!options.walk || options.walk(path, stats, entries) !== false) {
                for (const entry of entries) {
                    processFileOrDir(np.join(path, entry));
                }
            }
        };
        const getCache = (cacheObject, path) => {
            if (cacheObject) {
                const cache = cacheObject[path];
                if (cache && (!Array.isArray(cache) || typeof cache[0] !== "function")) {
                    return cache;
                }
            }
        };
        processFileOrDir(path);
    }
}
exports.walk = walk;
function readFile(path, callback, retry = 3) {
    if (typeof callback === "function") {
        nfs.readFile(path, (error, buffer) => {
            if (!error || error.code === "EISDIR" || error.code === "ENOENT" || retry === 0) {
                callback(error, buffer);
                resolve();
            }
            else {
                switch (error.code) {
                    case "EMFILE":
                    case "ENFILE":
                        delay(readFile, [path, callback, retry - 1]);
                        break;
                    default:
                        setTimeout(readFile, 7, path, callback, retry - 1);
                        break;
                }
            }
        });
    }
    else {
        try {
            return nfs.readFileSync(path);
        }
        catch (e) {
            if (e.code === "ENOENT" || e.code === "EISDIR" || retry === 0) {
                throw e;
            }
            return readFile(path, undefined, retry - 1);
        }
    }
}
exports.readFile = readFile;
function readFileIf(path, callback, retry = 3) {
    return readIf(readFile, () => Buffer.allocUnsafe(0), path, callback, retry);
}
exports.readFileIf = readFileIf;
/**
 * 写入指定的文件内容。
 * @param path 要写入的文件路径。
 * @param data 要写入的文件数据。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function writeFile(path, data, callback, retry = 3) {
    return write(nfs.writeFile, nfs.writeFileSync, path, data, callback, retry);
}
exports.writeFile = writeFile;
/**
 * 写入指定的文件内容，如果文件已存在则不写入。
 * @param path 要写入的文件路径。
 * @param data 要写入的文件数据。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function writeFileIf(path, data, callback, retry = 3) {
    writeIf(writeFile, path, path, data, callback, retry);
}
exports.writeFileIf = writeFileIf;
/**
 * 在指定文件末尾追加内容。
 * @param path 要创建的文件路径。
 * @param data 要写入的文件数据。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function appendFile(path, data, callback, retry = 3) {
    return write(nfs.appendFile, nfs.appendFileSync, path, data, callback, retry);
}
exports.appendFile = appendFile;
function write(asyncFunc, syncFunc, path, data, callback, retry) {
    if (typeof callback === "function") {
        asyncFunc(path, data, error => {
            if (!error || retry === 0) {
                callback(error);
                resolve();
            }
            else {
                switch (error.code) {
                    case "ENOENT":
                        ensureParentDir(path, () => {
                            write(asyncFunc, syncFunc, path, data, callback, retry - 1);
                        }, retry);
                        break;
                    case "EMFILE":
                    case "ENFILE":
                        delay(write, [asyncFunc, syncFunc, path, data, callback, retry - 1]);
                        break;
                    default:
                        setTimeout(write, 7, asyncFunc, syncFunc, path, data, callback, retry - 1);
                        break;
                }
            }
        });
    }
    else {
        try {
            syncFunc(path, data);
        }
        catch (e) {
            if (retry === 0) {
                throw e;
            }
            if (e.code === "ENOENT") {
                try {
                    ensureParentDir(path, undefined, retry);
                }
                catch (e2) {
                }
            }
            write(asyncFunc, syncFunc, path, data, undefined, retry - 1);
        }
    }
}
/**
 * 创建一个链接。
 * @param path 要创建的文件路径。
 * @param target 要链接的目标路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function createLink(path, target, callback, retry = 3) {
    if (typeof callback === "function") {
        existsFile(target, result => {
            const done = (error) => {
                if (!error || retry === 0) {
                    callback(error);
                }
                else {
                    switch (error.code) {
                        case "ENOENT":
                            ensureParentDir(path, () => {
                                createLink(path, target, callback, retry - 1);
                            }, retry);
                            break;
                        default:
                            setTimeout(createLink, 7, path, target, callback, retry - 1);
                            break;
                    }
                }
            };
            if (result) {
                nfs.link(target, path, done);
            }
            else {
                nfs.symlink(target, path, "junction", done);
            }
        }, retry);
    }
    else {
        try {
            if (existsFile(target, undefined, retry)) {
                nfs.linkSync(target, path);
            }
            else {
                nfs.symlinkSync(target, path, "junction");
            }
        }
        catch (e) {
            if (retry === 0) {
                throw e;
            }
            if (e.code === "ENOENT") {
                try {
                    ensureParentDir(path, undefined, retry);
                }
                catch (e2) { }
            }
            createLink(path, target, undefined, retry - 1);
        }
    }
}
exports.createLink = createLink;
/**
 * 创建一个链接，如果文件已存在则不写入。
 * @param path 要创建的文件路径。
 * @param target 要链接的目标路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function createLinkIf(path, target, callback, retry = 3) {
    writeIf(createLink, path, path, target, callback, retry);
}
exports.createLinkIf = createLinkIf;
function readLink(path, callback, retry = 3) {
    if (typeof callback === "function") {
        nfs.readlink(path, (error, link) => {
            if (error) {
                if (retry === 0) {
                    callback(error, null);
                }
                else {
                    readLink(path, callback, retry - 1);
                }
            }
            else {
                callback(error, link);
            }
        });
    }
    else {
        try {
            return nfs.readlinkSync(path);
        }
        catch (e) {
            if (retry === 0) {
                throw e;
            }
            return readLink(path, callback, retry - 1);
        }
    }
}
exports.readLink = readLink;
function readLinkIf(path, callback, errorIfNotFound = true, retry = 3) {
    return readIf(readLink, () => "", path, callback, retry);
}
exports.readLinkIf = readLinkIf;
/**
 * 复制指定的文件夹。
 * @param from 复制的源文件夹路径。
 * @param to 复制的目标文件夹路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function copyDir(from, to, callback, retry = 3) {
    copyFiles(from, to, callback, true, retry);
}
exports.copyDir = copyDir;
/**
 * 复制指定的文件夹，如果文件已存在则不复制。
 * @param from 复制的源文件夹路径。
 * @param to 复制的目标文件夹路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function copyDirIf(from, to, callback, retry = 3) {
    copyFiles(from, to, callback, false, retry);
}
exports.copyDirIf = copyDirIf;
function copyFiles(from, to, callback, overwrite, retry) {
    if (typeof callback === "function") {
        createDir(to, error => {
            if (error) {
                callback(error);
            }
            else {
                readDir(from, (error, entries) => {
                    if (error || !entries.length) {
                        callback(error);
                    }
                    else {
                        let pending = entries.length;
                        const done = (e) => {
                            if (e && !error) {
                                error = e;
                            }
                            if (--pending < 1) {
                                callback(error);
                            }
                        };
                        for (const entry of entries) {
                            const fromChild = np.join(from, entry);
                            getStatLink(fromChild, (error, stats) => {
                                if (error) {
                                    done(error);
                                }
                                else {
                                    const toChild = np.join(to, entry);
                                    if (stats.isDirectory()) {
                                        copyFiles(fromChild, toChild, done, overwrite, retry);
                                    }
                                    else if (stats.isSymbolicLink()) {
                                        overwrite ? copyLink(fromChild, toChild, done, retry) : copyLinkIf(fromChild, toChild, done, retry);
                                    }
                                    else {
                                        overwrite ? copyFile(fromChild, toChild, done, retry) : copyFileIf(fromChild, toChild, done, retry);
                                    }
                                }
                            }, retry);
                        }
                    }
                }, retry);
            }
        }, retry);
    }
    else {
        createDir(to, undefined, retry);
        let error;
        for (const entry of readDir(from, undefined, retry)) {
            const fromChild = np.join(from, entry);
            const toChild = np.join(to, entry);
            try {
                const stats = getStatLink(fromChild, undefined, retry);
                if (stats.isDirectory()) {
                    copyFiles(fromChild, toChild, undefined, overwrite, retry);
                }
                else if (stats.isSymbolicLink()) {
                    overwrite ? copyLink(fromChild, toChild, undefined, retry) : copyLinkIf(fromChild, toChild, undefined, retry);
                }
                else {
                    overwrite ? copyFile(fromChild, toChild, undefined, retry) : copyFileIf(fromChild, toChild, undefined, retry);
                }
            }
            catch (e) {
                if (!error) {
                    error = e;
                }
            }
        }
        if (error) {
            throw error;
        }
    }
}
/**
 * 复制指定的文件。
 * @param from 复制的源文件路径。
 * @param to 复制的目标文件路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function copyFile(from, to, callback, retry = 3) {
    let fdr;
    let fdw;
    if (typeof callback === "function") {
        const open = (path, read, retry = 3) => {
            nfs.open(path, read ? "r" : "w", 0o666, (error, fd) => {
                if (error) {
                    switch (error.code) {
                        case "EMFILE":
                        case "ENFILE":
                            delay(open, [path, read, retry - 1]);
                            break;
                        case "ENOENT":
                            if (!read && retry > 0) {
                                ensureParentDir(path, () => open(path, read, retry - 1), retry);
                                break;
                            }
                        // 继续执行
                        default:
                            if (retry === 0) {
                                end(error);
                            }
                            else {
                                setTimeout(open, 7, path, read, retry - 1);
                            }
                    }
                }
                else {
                    if (read) {
                        fdr = fd;
                    }
                    else {
                        fdw = fd;
                    }
                    if (fdr !== undefined && fdw !== undefined) {
                        copy(Buffer.allocUnsafe(64 * 1024), 0, retry);
                    }
                    resolve();
                }
            });
        };
        const copy = (buffer, pos, retry = 3) => {
            nfs.read(fdr, buffer, 0, buffer.length, pos, (error, bytesRead, buffer) => {
                if (error) {
                    if (retry === 0) {
                        end(error);
                    }
                    else {
                        setTimeout(copy, 7, buffer, pos, retry - 1);
                    }
                }
                else if (bytesRead === 0) {
                    end(error);
                }
                else {
                    nfs.write(fdw, buffer, 0, bytesRead, (error, writen, buffer) => {
                        if (error) {
                            if (retry === 0) {
                                end(error);
                            }
                            else {
                                setTimeout(copy, 7, buffer, pos, retry - 1);
                            }
                        }
                        else if (writen < buffer.length) {
                            end(error);
                        }
                        else {
                            copy(buffer, pos + writen, retry);
                        }
                    });
                }
            });
        };
        const end = (error) => {
            if (fdw != undefined) {
                nfs.close(fdw, () => {
                    fdw = undefined;
                    if (fdr == undefined) {
                        callback(error);
                    }
                });
            }
            if (fdr != undefined) {
                nfs.close(fdr, () => {
                    fdr = undefined;
                    if (fdw == undefined) {
                        callback(error);
                    }
                });
            }
        };
        open(from, true, retry);
        open(to, false, retry);
    }
    else {
        try {
            fdr = nfs.openSync(from, "r", 0o666);
            try {
                fdw = nfs.openSync(to, "w", 0o666);
            }
            catch (e) {
                if (e.code !== "ENOENT") {
                    throw e;
                }
                ensureParentDir(to, undefined, retry);
                fdw = nfs.openSync(to, "w", 0o666);
            }
            const buffer = Buffer.allocUnsafe(64 * 1024);
            let pos = 0;
            while (true) {
                const bytesRead = nfs.readSync(fdr, buffer, 0, buffer.length, pos);
                pos += nfs.writeSync(fdw, buffer, 0, bytesRead);
                if (bytesRead < buffer.length) {
                    break;
                }
            }
        }
        catch (e) {
            if (retry === 0) {
                throw e;
            }
            copyFile(from, to, undefined, retry - 1);
            return;
        }
        finally {
            if (fdw) {
                nfs.closeSync(fdw);
            }
            if (fdr) {
                nfs.closeSync(fdr);
            }
        }
    }
}
exports.copyFile = copyFile;
/**
 * 复制指定的文件，如果文件已存在则不复制。
 * @param from 复制的源文件路径。
 * @param to 复制的目标文件路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function copyFileIf(from, to, callback, retry = 3) {
    writeIf(copyFile, to, from, to, callback, retry);
}
exports.copyFileIf = copyFileIf;
/**
 * 复制指定的链接。
 * @param from 复制的源链接。
 * @param to 复制的目标链接。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function copyLink(from, to, callback, retry = 3) {
    if (typeof callback === "function") {
        readLink(from, (error, link) => {
            if (error) {
                callback(error);
            }
            else {
                createLink(to, link, callback, retry);
            }
        }, retry);
    }
    else {
        createLink(to, readLink(from, undefined, retry), undefined, retry);
    }
}
exports.copyLink = copyLink;
/**
 * 复制指定的链接，如果文件已存在则不复制。
 * @param from 复制的源链接。
 * @param to 复制的目标链接。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function copyLinkIf(from, to, callback, retry = 3) {
    writeIf(copyLink, to, from, to, callback, retry);
}
exports.copyLinkIf = copyLinkIf;
function readIf(func, defaultValue, path, callback, retry) {
    if (typeof callback === "function") {
        func(path, (error, data) => {
            if (error && error.code === "ENOENT") {
                callback(null, defaultValue());
            }
            else {
                callback(error, data);
            }
        }, retry);
    }
    else {
        try {
            return func(path, undefined, retry);
        }
        catch (e) {
            if (e.code !== "ENOENT") {
                throw e;
            }
        }
        return defaultValue();
    }
}
function writeIf(func, checkPath, path, data, callback, retry) {
    if (typeof callback === "function") {
        getStatLink(checkPath, error => {
            if (error && error.code === "ENOENT") {
                func(path, data, callback, retry);
            }
            else {
                callback(error);
            }
        }, retry);
    }
    else {
        try {
            getStatLink(checkPath, undefined, retry);
            return;
        }
        catch (e) {
            if (e.code !== "ENOENT") {
                throw e;
            }
        }
        func(path, data, undefined, retry);
    }
}
/**
 * 移动指定的文件夹。
 * @param from 移动的源文件夹路径。
 * @param to 移动的目标文件夹路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function moveDir(from, to, callback, retry = 3) {
    if (typeof callback === "function") {
        createDir(to, error => {
            if (error) {
                callback(error);
            }
            else {
                readDir(from, (error, entries) => {
                    if (error || !entries.length) {
                        callback(error);
                    }
                    else {
                        let pending = entries.length;
                        const done = (e) => {
                            if (e && !error) {
                                error = e;
                            }
                            if (--pending < 1) {
                                deleteDir(from, e => {
                                    if (e && !error) {
                                        error = e;
                                    }
                                    callback(error);
                                }, retry);
                            }
                        };
                        for (const entry of entries) {
                            const fromChild = np.join(from, entry);
                            getStatLink(fromChild, (error, stats) => {
                                if (error) {
                                    done(error);
                                }
                                else {
                                    const toChild = np.join(to, entry);
                                    if (stats.isDirectory()) {
                                        moveDir(fromChild, toChild, done, retry);
                                    }
                                    else if (stats.isSymbolicLink()) {
                                        copyLink(fromChild, toChild, error => {
                                            if (error) {
                                                done(error);
                                            }
                                            else {
                                                deleteFile(toChild, done);
                                            }
                                        }, retry);
                                    }
                                    else {
                                        moveFile(fromChild, toChild, done, retry);
                                    }
                                }
                            }, retry);
                        }
                    }
                }, retry);
            }
        }, retry);
    }
    else {
        createDir(to, undefined, retry);
        let error;
        for (const entry of readDir(from, undefined, retry)) {
            const fromChild = np.join(from, entry);
            const toChild = np.join(to, entry);
            try {
                const stats = getStatLink(fromChild, undefined, retry);
                if (stats.isDirectory()) {
                    moveDir(fromChild, toChild, undefined, retry);
                }
                else if (stats.isSymbolicLink()) {
                    copyLink(fromChild, toChild, undefined, retry);
                    deleteFile(toChild);
                }
                else {
                    moveFile(fromChild, toChild, undefined, retry);
                }
            }
            catch (e) {
                if (!error) {
                    error = e;
                }
            }
        }
        if (error) {
            throw error;
        }
        deleteDir(from, undefined, retry);
    }
}
exports.moveDir = moveDir;
/**
 * 移动指定的文件。
 * @param from 移动的源文件路径。
 * @param to 移动的目标文件路径。
 * @param callback 异步操作完成后的回调函数。如果不是函数则以同步的方式执行。
 * @param retry 操作失败后自动重试的次数。
 */
function moveFile(from, to, callback, retry = 3) {
    if (typeof callback === "function") {
        nfs.rename(from, to, error => {
            if (!error) {
                callback(null);
            }
            else {
                copyFile(from, to, error => {
                    if (error) {
                        callback(error);
                    }
                    else {
                        deleteFile(from, callback, retry);
                    }
                }, retry);
            }
        });
    }
    else {
        try {
            nfs.renameSync(from, to);
        }
        catch (e) {
            copyFile(from, to, undefined, retry);
            deleteFile(from, undefined, retry);
        }
    }
}
exports.moveFile = moveFile;
function getChecksum(path, comparion = 21 /* default */, callback, stats, buffer, retry = 3) {
    const parts = [];
    if (comparion & (1 /* createTime */ | 2 /* lastAccessTime */ | 4 /* lastWriteTime */ | 16 /* size */)) {
        if (!stats) {
            if (typeof callback === "function") {
                getStat(path, (error, stats) => {
                    if (error) {
                        callback(error, null);
                    }
                    else {
                        getChecksum(path, comparion, callback, stats, buffer, retry);
                    }
                }, retry);
                return;
            }
            else {
                stats = getStat(path, undefined, retry);
            }
        }
        if (comparion & 1 /* createTime */) {
            parts.push((+stats.birthtime).toString(36));
        }
        if (comparion & 2 /* lastAccessTime */) {
            parts.push((+stats.atime).toString(36));
        }
        if (comparion & 8 /* lastChangeTime */) {
            parts.push((+stats.ctime).toString(36));
        }
        if (comparion & 4 /* lastWriteTime */) {
            parts.push((+stats.mtime).toString(36));
        }
        if (comparion & 16 /* size */) {
            parts.push(stats.size.toString(36));
        }
    }
    if (comparion & (1024 /* sha1 */ | 2048 /* md5 */ | 4096 /* data */)) {
        if (!buffer) {
            if (typeof callback === "function") {
                readFile(path, (error, buffer) => {
                    if (error) {
                        callback(error, null);
                    }
                    else {
                        getChecksum(path, comparion, callback, stats, buffer, retry);
                    }
                }, retry);
                return;
            }
            else {
                buffer = readFile(path, undefined, retry);
            }
        }
        if (comparion & 1024 /* sha1 */) {
            parts.push(crypto_1.sha1(buffer));
        }
        if (comparion & 2048 /* md5 */) {
            parts.push(crypto_1.md5(buffer));
        }
        if (comparion & 4096 /* data */) {
            parts.push(buffer.toString("base64"));
        }
    }
    const checksum = parts.join("|");
    if (typeof callback === "function") {
        callback(null, checksum);
    }
    else {
        return checksum;
    }
}
exports.getChecksum = getChecksum;
/**
 * 表示文件比较的算法。
 */
var FileComparion;
(function (FileComparion) {
    /**
     * 比较文件创建时间。
     */
    FileComparion[FileComparion["createTime"] = 1] = "createTime";
    /**
     * 比较最后访问时间。
     */
    FileComparion[FileComparion["lastAccessTime"] = 2] = "lastAccessTime";
    /**
     * 比较最后修改时间。
     */
    FileComparion[FileComparion["lastWriteTime"] = 4] = "lastWriteTime";
    /**
     * 比较最后修改时间。
     */
    FileComparion[FileComparion["lastChangeTime"] = 8] = "lastChangeTime";
    /**
     * 比较文件大小。
     */
    FileComparion[FileComparion["size"] = 16] = "size";
    /**
     * 比较 SHA1 值。
     */
    FileComparion[FileComparion["sha1"] = 1024] = "sha1";
    /**
     * 比较 MD5 值。
     */
    FileComparion[FileComparion["md5"] = 2048] = "md5";
    /**
     * 比较文件数据。
     */
    FileComparion[FileComparion["data"] = 4096] = "data";
    /**
     * 默认比较算法。
     */
    FileComparion[FileComparion["default"] = 21] = "default";
})(FileComparion = exports.FileComparion || (exports.FileComparion = {}));
/**
 * 表示一个已延时的调用链表尾。
 */
var delayed;
/**
 * 全局回调计时器。
 */
var timer;
/**
 * 延时执行指定的函数。
 * @param func 要执行的函数。
 * @param args 要执行的参数。
 */
function delay(func, args) {
    args.callee = func;
    const end = delayed;
    if (end) {
        args.next = end.next;
        end.next = delayed = args;
    }
    else {
        args.next = delayed = args;
    }
    // 如果直接调用原生的 fs 函数导致了文件打开过多，
    // 则可能不会执行已延时的函数，
    // 等待一段时间后强制重新执行。
    if (!timer) {
        timer = setTimeout(resolve, 7000);
    }
}
/**
 * 执行一个已延时的函数。
 */
function resolve() {
    if (delayed) {
        const head = delayed.next;
        if (head === delayed) {
            delayed = undefined;
        }
        else {
            delayed.next = head.next;
        }
        head.callee(...head);
        if (timer) {
            clearTimeout(timer);
            timer = undefined;
        }
    }
}
