"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const queue_1 = require("./queue");
/**
 * 表示一个异步队列。
 * @desc
 * 异步队列可以缓冲多个函数，让这些函数串行执行。
 * 队列实现了加锁/解锁模型，加锁时，所以函数都会等待解锁后再执行。
 * @example
 * var q = new AsyncQueue();
 * q.enquee(function () { });
 * q.enquee(function (done) { setTimeout(done, 1000); });
 * q.enquee(function () { return new Promise(resolve => setTimeout(resolve, 1000)); });
 * q.enquee(function () { q.lock(); setTimeout(() => q.unlock(), 1000); });
 */
class AsyncQueue extends queue_1.default {
    constructor() {
        super(...arguments);
        /**
         * 存储当前锁定的次数。
         */
        this._lock = 0;
        /**
         * 解锁当前队列。解锁后所有函数恢复执行。
         * @param message 指定锁定的来源以供调试。
         */
        this.unlock = (message) => {
            // 删除此注释以启用异步调试：
            // require("fs").appendFileSync("./async-debug.log", "\n-" + message);
            console.assert(this._lock > 0, `AsyncQueue: unexpected unlock(). ${message || ""}`);
            this._lock--;
            this.dequeue();
        };
    }
    /**
     * 锁定当前队列。锁定后所有函数都将进入等待状态。
     * @param message 指定锁定的来源以供调试。
     */
    lock(message) {
        // 删除此注释以启用异步调试：
        // require("fs").appendFileSync("./async-debug.log", "\n+" + message);
        this._lock++;
    }
    /**
     * 在当前队列末尾添加一个回调函数。
     * @param callback 要添加的回调函数。
     */
    enqueue(callback) {
        const first = this.empty;
        super.enqueue(callback);
        if (first) {
            this.dequeue();
        }
    }
    /**
     * 从当前队列顶部取出一个回调函数并执行。
     * @return 返回取出的回调函数。如果队列为空或已锁定则返回 undefined。
     */
    dequeue() {
        if (this._lock === 0) {
            const item = super.dequeue();
            if (item) {
                this.lock();
                const ret = item();
                if (ret instanceof Promise) {
                    ret.then(this.unlock, this.unlock);
                }
                else {
                    this.unlock();
                }
            }
            return item;
        }
    }
    /**
     * 创建和当前队列等价的确认对象(Promise)。
     * @return 返回一个确认对象(Promise)。
     */
    promise() { return new Promise(resolve => this.enqueue(resolve)); }
}
exports.AsyncQueue = AsyncQueue;
exports.default = AsyncQueue;
