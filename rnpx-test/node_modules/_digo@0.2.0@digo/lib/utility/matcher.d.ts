/**
 * 表示一个匹配器。
 */
export declare class Matcher {
    /**
     * 所有已编译的模式列表。
     */
    readonly patterns: CompiledPattern[];
    /**
     * 当前匹配器的忽略匹配器。如果不存在则返回 undefined。
     */
    ignoreMatcher?: Matcher;
    /**
     * 初始化新的匹配器。
     * @param pattern 要添加的匹配模式。
     * @param cwd 模式的根路径。默认当前工作文件夹。
     */
    constructor(pattern?: Pattern, cwd?: string);
    /**
     * 添加一个匹配模式。
     * @param pattern 要添加的匹配模式。
     * @param cwd 模式的根路径。默认当前工作文件夹。
     */
    add(pattern: Pattern, cwd?: string): void;
    /**
     * 添加一个忽略模式。
     * @param pattern 要添加的模式。
     * @param cwd 模式的根路径。默认当前工作文件夹。
     */
    addIgnore(pattern: Pattern, cwd?: string): void;
    /**
     * 测试指定的绝对路径是否符合当前匹配器。
     * @param path 要测试的绝对路径。
     * @return 如果匹配任意一个已添加的模式且未被忽略则返回 true，否则返回 false。
     */
    test(path: string): boolean;
    /**
     * 获取所有模式的公共基路径。
     * @return 返回基路径。如果无法获取获取则返回 null。
     */
    readonly base: string;
    /**
     * 测试指定的内容是否符合指定的模式。
     * @param value 要测试的内容。
     * @param pattern 要测试的匹配模式。
     * @param cwd 模式的根路径。默认当前工作文件夹。
     * @return 如果匹配则返回 true，否则返回 false。
     */
    static test(value: string, pattern: Pattern, cwd?: string): boolean;
}
export default Matcher;
/**
 * 表示一个模式。可以是通配符、正则表达式、测试函数或以上模式组成的数组。
 * @desc
 * ##### 通配符
 * 通配符的语法和 [`.gitignore`](https://git-scm.com/docs/gitignore) 相同。
 *
 * 通配符中可以使用以下特殊字符：
 *
 * - `*`: 匹配任意个 / 以外的字符。
 * - `**`:匹配任意个字符。
 * - `?`: 匹配一个 / 以外的字符。
 * - `[abc]`: 匹配括号中的任一个字符。
 * - `[^abc]`: 匹配括号中的任一个字符以外的字符。
 * - `\`: 表示转义字符。如 `\[`。
 *
 * 在通配符前面加 `!`，表示忽略匹配的项(反向匹配)。
 * 注意如果忽略了父文件夹，出于性能考虑，无法重新包含其中的子文件。
 *
 * 如果通配符以 `/` 结尾，表示只匹配文件夹。
 *
 * 关于 `*` 和 `**` 的区别：
 *
 * - `**` 则匹配任意层目录(包括没有)。比如 `usr/**\/foo.js` 既匹配 `usr/dir/foo.js`，也匹配 `usr/foo.js` 和 `usr/dir/sub/foo.js`。
 * - `*` 只匹配一层目录。比如 `usr/*\/foo.js` 匹配 `usr/dir/foo.js`，但不匹配 `usr/foo.js`，也不匹配 `usr/dir/sub/foo.js`。
 * - 特殊情况：如果通配符不含 /(末尾除外)，则两者意义相同：都表示匹配任意层目录。比如 `*.js` 既匹配 `foo.js` 也匹配 `usr/foo.js`。如果希望只匹配当前目录下的文件，应该写成 `./*.js`。
 *
 * 直接使用文件夹名，如 `foo/www` 等效于 `foo/www/**`。
 *
 * 绝对路径可以直接作通配符使用。
 *
 * ##### 正则表达式
 * 复杂的匹配规则可以使用正则表达式。
 * 测试的源是一个固定以 / 为分隔符的相对路径。
 *
 * ##### 自定义函数
 * 函数接收一个绝对路径为参数，如果函数返回 true 表示匹配该路径。
 * ```js
 * function match(path) {
 *     return path.endsWith(".js");
 * }
 * ```
 */
export declare type Pattern = string | RegExp | ((path: string) => boolean) | any[] | Matcher | null;
/**
 * 表示一个已编译的模式。
 */
export interface CompiledPattern {
    /**
     * 模式基路径。
     */
    base: string;
    /**
     * 测试当前模式是否匹配指定的路径。
     * @param path 要测试的绝对路径。
     * @return 如果匹配则返回 true，否则返回 false。
     */
    test(path: string): boolean;
}
