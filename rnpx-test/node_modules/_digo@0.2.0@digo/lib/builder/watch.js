"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lang_1 = require("../utility/lang");
const fsWatcher_1 = require("../utility/fsWatcher");
const matcher_1 = require("../utility/matcher");
const async_1 = require("./async");
const events_1 = require("./events");
const logging_1 = require("./logging");
const src_1 = require("./src");
const file = require("./file");
const logging = require("./logging");
const progress = require("./progress");
/**
 * 表示一个监听器。
 */
class Watcher extends fsWatcher_1.FSWatcher {
    constructor() {
        super(...arguments);
        /**
         * 缓存所有已更新的文件。
         */
        this.changed = [];
        /**
         * 缓存所有已删除的文件。
         */
        this.deleted = [];
        /**
         * 存储所有模块的依赖关系。
         */
        this.deps = { __proto__: null };
        /**
         * 获取所有根节点列表。
         */
        this.rootLists = [];
        /**
         * 判断当前监听器是否已初始化。
         */
        this.inited = false;
    }
    /**
     * 判断是否忽略指定的路径。
     * @param path 要判断的文件或文件夹绝对路径。
     * @return 如果应忽略指定的路径则返回 true，否则返回 false。
     */
    ignored(path) { return !src_1.globalMatcher.test(path); }
    /**
     * 当监听到文件删除后执行。
     * @param path 相关的文件绝对路径。
     * @param lastWriteTime 最后修改时间。
     */
    onDelete(path, lastWriteTime) {
        this.addDelete(path);
        const changedFileCount = this.changed.length + this.deleted.length;
        logging_1.info(changedFileCount > 1 ? "{brightBlack:now} {brightCyan:Deleted}: {bright:file}{brightBlack:(+}{brightBlack:hidden}{brightBlack:)}" : "{brightBlack:now} {brightCyan:Deleted}: {bright:file}", {
            now: lang_1.formatDate(undefined, "[HH:mm:ss]"),
            file: logging_1.getDisplayName(path),
            hidden: changedFileCount - 1
        });
        this.rebuild();
        super.onDelete(path, lastWriteTime);
    }
    /**
     * 当监听到文件创建后执行。
     * @param path 相关的文件绝对路径。
     * @param stats 文件属性对象。
     */
    onCreate(path, stats) {
        this.addChange(path);
        const changedFileCount = this.changed.length + this.deleted.length;
        logging_1.info(changedFileCount > 1 ? "{brightBlack:now} {brightCyan:Created}: {bright:file}{brightBlack:(+}{brightBlack:hidden}{brightBlack:)}" : "{brightBlack:now} {brightCyan:Created}: {bright:file}", {
            now: lang_1.formatDate(undefined, "[HH:mm:ss]"),
            file: logging_1.getDisplayName(path),
            hidden: changedFileCount - 1
        });
        this.rebuild();
        super.onCreate(path, stats);
    }
    /**
     * 当监听到文件改变后执行。
     * @param path 相关的文件绝对路径。
     * @param stats 相关的文件属性对象。
     * @param lastWriteTime 最后修改时间。
     */
    onChange(path, stats, lastWriteTime) {
        this.addChange(path);
        const changedFileCount = this.changed.length + this.deleted.length;
        logging_1.info(changedFileCount > 1 ? "{brightBlack:now} {brightCyan:Changed}: {bright:file}(+{hidden})" : "{brightBlack:now} {brightCyan:Changed}: {bright:file}", {
            now: lang_1.formatDate(undefined, "[HH:mm:ss]"),
            file: logging_1.getDisplayName(path),
            hidden: changedFileCount - 1
        });
        this.rebuild();
        super.onChange(path, stats, lastWriteTime);
    }
    /**
     * 当监听发生错误后执行。
     * @param e 相关的错误对象。
     * @param path 相关的文件绝对路径。
     */
    onError(e, path) {
        logging_1.error(e);
    }
    /**
     * 添加一个已更新的文件。
     * @param path 已更新的文件绝对路径。
     */
    addChange(path) {
        if (this.changed.indexOf(path) >= 0) {
            return;
        }
        if (this.deleted.indexOf(path) >= 0) {
            this.deleted.splice(this.deleted.indexOf(path), 1);
        }
        this.changed.push(path);
        for (const key in this.deps) {
            if (this.deps[key].indexOf(path) >= 0) {
                this.addChange(key);
            }
        }
    }
    /**
     * 添加一个已删除的文件。
     * @param path 已删除的文件绝对路径。
     */
    addDelete(path) {
        if (this.deleted.indexOf(path) >= 0) {
            return;
        }
        if (this.changed.indexOf(path) >= 0) {
            this.changed.splice(this.changed.indexOf(path), 1);
        }
        this.deleted.push(path);
        for (const key in this.deps) {
            if (this.deps[key].indexOf(path) >= 0) {
                this.addChange(key);
            }
        }
    }
    /**
     * 重新构建发生改变的文件。
     */
    rebuild() {
        async_1.then(() => {
            this.reset();
            this.emit("rebuild", this.changed, this.deleted);
            for (const list of this.rootLists) {
                let added = false;
                for (const p of this.deleted) {
                    if (list.matcher.test(p)) {
                        added = true;
                        const f = list.createFile(p);
                        if (f.buildMode !== 2 /* preview */) {
                            f.buildMode = 1 /* clean */;
                            list.add(f);
                        }
                    }
                }
                for (const p of this.changed) {
                    if (list.matcher.test(p)) {
                        added = true;
                        list.add(list.createFile(p));
                    }
                }
                if (added) {
                    list.end();
                }
            }
            this.deleted.length = this.changed.length = 0;
        });
    }
    /**
     * 清理生成器的状态。
     */
    reset() {
        file.fileCount = logging.errorCount = logging.warningCount = 0;
        progress.taskCount = progress.doneTaskCount = 0;
    }
    /**
     * 执行并开始监听指定的任务。
     * @param task 执行的任务名。
     * @param callback 开始监听的回调。
     */
    start(task, callback) {
        const addList = (value) => {
            if (value.matcher.patterns.length || value.matcher.ignoreMatcher) {
                this.rootLists.push(value);
            }
        };
        const addFile = (path, stats) => {
            this._stats[path] = stats.mtime.getTime();
        };
        const addDir = (path, stats, entries) => {
            this._stats[path] = entries;
        };
        events_1.on("addList", addList);
        events_1.on("addFile", addFile);
        events_1.on("addDir", addDir);
        events_1.on("fileDep", this.addDep = this.addDep.bind(this));
        async_1.then(task);
        async_1.then(() => {
            events_1.off("addList", addList);
            events_1.off("addFile", addFile);
            events_1.off("addDir", addDir);
            for (const list of this.rootLists) {
                addWatch(this, list.matcher);
            }
            for (const path in this.deps) {
                this.add(path);
                for (const dep of this.deps[path]) {
                    if (!(dep in this.deps)) {
                        this.add(dep);
                    }
                }
            }
            this.inited = true;
            callback && callback();
        });
    }
    /**
     * 添加文件的依赖项。
     * @param file 相关的文件。
     * @param dep 依赖的绝对路径。
     */
    addDep(file, path) {
        if (file.initialPath) {
            let deps = this.deps[file.initialPath];
            if (!deps) {
                deps = this.deps[file.initialPath] = [];
                this.inited && this.add(file.initialPath);
            }
            if (deps.indexOf(path) < 0) {
                deps.push(path);
                this.inited && this.add(path);
            }
        }
    }
    /**
     * 删除所有监听器。
     * @param callback 删除完成后的回调函数。
     */
    close(callback) {
        this.inited = false;
        events_1.off("fileDep", this.addDep);
        super.close(callback);
    }
}
exports.Watcher = Watcher;
/**
 * 是否采用轮询监听的方式。
 */
exports.polling = null;
/**
 * 当前使用的监听器。
 */
exports.watcher = null;
function watch(pattern, listener) {
    if (typeof listener === "function") {
        const result = new fsWatcher_1.FSWatcher();
        result.usePolling = exports.polling;
        const matcher = new matcher_1.Matcher(pattern);
        result.ignored = path => {
            if (matcher.ignoreMatcher && matcher.ignoreMatcher.test(path)) {
                return true;
            }
            return !src_1.globalMatcher.test(path);
        };
        result.on("delete", path => { listener("delete", path); });
        result.on("change", path => { listener("change", path); });
        result.on("create", path => { listener("create", path); });
        result.on("error", logging_1.error);
        addWatch(result, matcher);
        return result;
    }
    if (exports.watcher) {
        exports.watcher.close();
    }
    exports.watcher = new Watcher();
    exports.watcher.usePolling = exports.polling;
    exports.watcher.start(pattern);
    return exports.watcher;
}
exports.watch = watch;
/**
 * 添加指定匹配器符合的文件夹。
 * @param watcher 要添加的监听器。
 * @param matcher 要添加的匹配器。
 */
function addWatch(watcher, matcher) {
    for (const pattern of (matcher.patterns.length ? matcher.patterns : [{
            base: process.cwd()
        }])) {
        async_1.asyncQueue.lock("addWatch:" + pattern.base);
        watcher.add(pattern.base, () => {
            async_1.asyncQueue.unlock("addWatch:" + pattern.base);
        });
    }
}
