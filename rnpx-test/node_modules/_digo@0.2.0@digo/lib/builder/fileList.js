"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const matcher_1 = require("../utility/matcher");
const plugin_1 = require("./plugin");
const progress_1 = require("./progress");
/**
 * 表示一个文件列表。
 */
class FileList {
    constructor() {
        // #region 链表
        // #endregion
        // #region 处理器
        /**
         * 当前列表的处理器。
         */
        this.processor = emptyObject;
        /**
         * 当前列表的处理器选项。
         */
        this.processorOptions = emptyObject;
        /**
         * 存储是否正在添加文件。
         */
        this._adding = false;
        /**
         * 存储当前列表的等待任务数。
         */
        this._pending = 0;
        // #endregion
    }
    /**
     * 获取当前列表的根列表。
     */
    get root() {
        let result = this;
        while (result.prev) {
            result = result.prev;
        }
        return result;
    }
    /**
     * 获取当前列表的最终结果列表。
     */
    get result() {
        let result = this;
        while (result.next) {
            result = result.next;
        }
        return result;
    }
    /**
     * 判断当前列表是否包含指定的子级列表。
     * @param child 要判断的列表。
     * @return 如果包含则返回 true，否则返回 false。
     */
    hasNext(child) {
        if (!this.prev || this === child) {
            return true;
        }
        for (let list = this; list = list.next;) {
            if (list.prev === this && list.hasNext(child)) {
                return true;
            }
        }
        return false;
    }
    /**
     * 向当前列表添加一个文件。
     * @param file 要添加的文件。
     * @param root 文件所属的根列表。
     */
    add(file, root = this.prev) {
        if (root && !root.hasNext(this)) {
            return;
        }
        this.onBefore();
        this._pending++;
        if (this.processor.load && !file.loaded) {
            file.load((error, file) => {
                this.onLoad(file, root);
            });
        }
        else {
            this.onLoad(file, root);
        }
    }
    /**
     * 通知当前列表所有文件已添加。
     */
    end() {
        this.onBefore();
        if (this.processor.after) {
            this.processor.after(this.processorOptions, this);
        }
        this.onAfter();
    }
    /**
     * 检查是否可触发 before 事件。
     */
    onBefore() {
        if (!this._adding) {
            this._adding = true;
            this._pending++;
            if (this.processor.before) {
                this.processor.before(this.processorOptions, this);
            }
        }
    }
    /**
     * 当文件已载入后执行。
     * @param file 要添加的文件。
     * @param root 文件所属的根列表。
     */
    onLoad(file, root) {
        if (this.processor.add) {
            const taskId = this.processor.name && progress_1.begin("{processor}: {file}", {
                processor: this.processor.name,
                file: file.toString()
            });
            if (this.processor.add.length <= 2) {
                const addToNext = this.processor.add(file, this.processorOptions);
                taskId && progress_1.end(taskId);
                this.onAdd(file, root, addToNext);
            }
            else {
                this.processor.add(file, this.processorOptions, addToNext => {
                    taskId && progress_1.end(taskId);
                    this.onAdd(file, root, addToNext);
                }, this.next || new FileList(), root);
            }
        }
        else {
            this.onAdd(file, root);
        }
    }
    /**
     * 当文件已添加后执行。
     * @param file 要添加的文件。
     * @param root 文件所属的根列表。
     * @param addToNext 是否将当前文件传递给下级处理。
     */
    onAdd(file, root, addToNext) {
        if (this.processor.collect) {
            this.files = this.files || [];
            let index;
            if (file.initialPath) {
                for (index = 0; index < this.files.length; index++) {
                    if (this.files[index].initialPath === file.initialPath) {
                        break;
                    }
                }
            }
            else {
                index = this.files.length;
            }
            if (file.buildMode === 1 /* clean */) {
                this.files.splice(index, 1);
            }
            else {
                this.files[index] = file.clone();
            }
        }
        let next = this.next;
        if (next) {
            if (typeof addToNext === "boolean" ? addToNext === false : this.processor.collect) {
                while (next && this.hasNext(next)) {
                    next = next.next;
                }
            }
            if (next) {
                next.add(file, root);
            }
        }
        this.onAfter();
    }
    /**
     * 检查是否可触发 end 事件。
     */
    onAfter() {
        if (--this._pending < 1) {
            if (this.processor.end) {
                if (this.processor.collect) {
                    this.files = this.files || [];
                    const taskId = this.processor.name && progress_1.begin("{processor}: {count} file(s)", {
                        processor: this.processor.name,
                        count: this.files.length
                    });
                    const onEnd = () => {
                        taskId && progress_1.end(taskId);
                        for (let i = this.files.length; --i >= 0;) {
                            if (!this.files[i].initialPath) {
                                this.files.splice(i, 1);
                            }
                        }
                        this.onEnd();
                    };
                    if (this.processor.end.length <= 3) {
                        this.processor.end(this.files, this.processorOptions, this.next || new FileList());
                        onEnd();
                    }
                    else {
                        this.processor.end(this.files, this.processorOptions, this.next || new FileList(), onEnd);
                    }
                }
                else {
                    if (this.processor.end.length <= 3) {
                        this.processor.end(undefined, this.processorOptions, this.next || new FileList());
                        this.onEnd();
                    }
                    else {
                        this.processor.end(undefined, this.processorOptions, this.next || new FileList(), () => {
                            this.onEnd();
                        });
                    }
                }
            }
            else {
                this.onEnd();
            }
        }
    }
    /**
     * 当作为顶级列表时表示所有子列表执行完成后的回调。
     */
    done() { }
    /**
     * 当所有文件已添加时执行。
     */
    onEnd() {
        this._pending = 0;
        this._adding = false;
        if (this.next) {
            this.next.end();
        }
        else {
            const root = this.root;
            root.done && root.done();
        }
    }
    // #endregion
    // #region 对外接口
    /**
     * 将当前列表所有文件传递给指定的处理器。
     * @param processor 要传递的目标处理器。
     * @param options 供处理器使用的只读配置对象。
     * @return 返回用于接收处理后文件的文件列表。
     * @example
     * list.pipe((file) => file.content += "1");
     * list.pipe((file, options, done) => done());
     */
    pipe(processor, options = emptyObject) {
        if (typeof processor === "string") {
            processor = plugin_1.plugin(processor);
        }
        if (typeof processor === "function") {
            processor = {
                name: processor.name,
                load: true,
                add: processor
            };
        }
        else if (processor == undefined) {
            processor = emptyObject;
        }
        if (processor.init) {
            const t = processor.init(options, this);
            if (t !== undefined) {
                options = t;
            }
        }
        if (processor.collect == undefined && processor.end && processor.end.length > 0) {
            processor.collect = true;
        }
        const result = new FileList();
        result.processor = processor;
        result.processorOptions = options;
        result.prev = this;
        return this.result.next = result;
    }
    /**
     * 设置当前列表完成后的回调函数。
     * @param callback 要执行的回调函数。
     * @return 返回用于接收处理后文件的文件列表。
     */
    then(callback) {
        return this.pipe({
            collect: false,
            end(files, options, dest, done) {
                const ret = callback();
                if (ret instanceof Promise) {
                    ret.then(done);
                }
                else {
                    process.nextTick(done);
                }
            }
        });
    }
    /**
     * 筛选当前文件列表并返回一个新的文件列表。
     * @param patterns 用于筛选文件的通配符、正则表达式、函数或以上模式组合的数组。
     * @return 返回已筛选的文件列表。
     */
    src(...patterns) {
        return this.pipe({
            add(file, matcher) {
                return file.path != undefined && matcher.test(file.path);
            }
        }, new matcher_1.Matcher(patterns));
    }
    /**
     * 将所有文件移动到指定的文件夹。
     * @param dir 要保存的目标文件文件夹。如果为空则保存到原文件夹。
     * @return 返回用于接收处理后文件的文件列表。
     */
    dest(dir = "") {
        return this.pipe({
            add(file, dir, done) {
                file.save(dir, done);
            }
        }, dir);
    }
    /**
     * 删除所有源文件。
     * @param deleteDir 指示是否删除空的父文件夹。
     * @return 返回用于接收处理后文件的文件列表。
     */
    delete(deleteDir = true) {
        return this.pipe({
            add(file, deleteDir, done) {
                file.delete(deleteDir, done);
            }
        }, deleteDir);
    }
    /**
     * 创建当前列表所有文件的副本。
     * @return 返回用于接收处理后文件的文件列表。
     */
    clone() {
        return this.pipe({
            add(file, options, done, result) {
                result.add(file.clone());
                done(false);
            }
        });
    }
}
exports.FileList = FileList;
const emptyObject = Object.freeze({});
