"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const encode_1 = require("../utility/encode");
const fs_1 = require("../utility/fs");
const location_1 = require("../utility/location");
const matcher_1 = require("../utility/matcher");
const lang_1 = require("../utility/lang");
const path_1 = require("../utility/path");
const sourceMap_1 = require("../utility/sourceMap");
const events_1 = require("./events");
const logging_1 = require("./logging");
const progress_1 = require("./progress");
const writer_1 = require("./writer");
/**
 * 表示一个文件。
 */
class File {
    /**
     * 初始化新的文件。
     * @param path 文件的初始路径。
     * @param base 文件的基路径。
     */
    constructor(path, base) {
        // #endregion
        // #region 读写
        /**
         * 当前文件的生成模式。
         */
        this.buildMode = exports.buildMode;
        // #endregion
        // #region 日志
        /**
         * 获取当前文件累积的错误数。
         */
        this.errorCount = 0;
        /**
         * 获取当前文件累积的警告数。
         */
        this.warningCount = 0;
        this.base = path_1.resolvePath(base || "");
        if (path != undefined) {
            this.path = this.initialPath = path_1.resolvePath(path);
        }
    }
    /**
     * 获取当前文件的源绝对路径。
     */
    get srcPath() { return this.initialPath || path_1.resolvePath("<generated>"); }
    /**
     * 获取当前文件的目标绝对路径。
     */
    get destPath() { return this.path || this.srcPath; }
    /**
     * 当前文件的绝对路径。如果未设置保存路径则返回 undefined。
     */
    get path() { return this.name == undefined ? undefined : path_1.resolvePath(this.base, this.name); }
    set path(value) {
        this.name = value == undefined ? undefined : path_1.relativePath(this.base, value);
        // 生成文件默认将第一次设置的路径作为源路径。
        if (!this.initialPath && this.srcPath === path_1.resolvePath("<generated>")) {
            lang_1.setProperty(this, "srcPath", this.path);
        }
    }
    /**
     * 获取当前文件的源文件夹绝对路径。
     */
    get srcDir() { return path_1.getDir(this.srcPath); }
    /**
     * 获取当前文件的目标文件夹绝对路径。
     */
    get destDir() { return path_1.getDir(this.destPath); }
    /**
     * 当前文件的文件夹绝对路径。
     */
    get dir() { return this.path == undefined ? undefined : path_1.getDir(this.path); }
    set dir(value) { this.path = value == undefined ? undefined : path_1.setDir(this.destPath, value); }
    /**
     * 获取当前文件的源扩展名。
     */
    get srcExt() { return path_1.getExt(this.srcPath); }
    /**
     * 获取当前文件的目标扩展名。
     */
    get destExt() { return path_1.getExt(this.destPath); }
    /**
     * 当前文件的扩展名。
     */
    get ext() { return this.name == undefined ? undefined : path_1.getExt(this.name); }
    set ext(value) { this.name = path_1.setExt(this.name || "", value || ""); }
    /**
     * 获取当前文件的字符串形式。
     */
    toString() { return logging_1.getDisplayName(this.srcPath); }
    /**
     * 提供直接查看当前文件对象的方法。
     */
    inspect() { return `File ${this.srcPath}`; }
    /**
     * 获取当前文件的源二进制内容。
     */
    get srcBuffer() {
        if (this._srcBuffer == undefined) {
            if (this._srcContent == undefined) {
                if (this.initialPath && this.buildMode !== 1 /* clean */) {
                    const task = progress_1.begin("Reading: {file}", { file: this });
                    try {
                        this._srcBuffer = fs_1.readFile(this.initialPath);
                    }
                    catch (e) {
                        this._srcBuffer = Buffer.allocUnsafe(0);
                        this.error({
                            error: e,
                            showStack: false
                        });
                    }
                    finally {
                        progress_1.end(task);
                    }
                }
                else {
                    this._srcBuffer = Buffer.allocUnsafe(0);
                }
            }
            else {
                this._srcBuffer = encode_1.stringToBuffer(this._srcContent, this.encoding);
            }
        }
        return this._srcBuffer;
    }
    /**
     * 获取当前文件的源文本内容。
     */
    get srcContent() {
        if (this._srcContent == undefined) {
            this._srcContent = encode_1.bufferToString(this.srcBuffer, this.encoding);
        }
        return this._srcContent;
    }
    /**
     * 获取当前文件的目标二进制内容。
     */
    get destBuffer() { return this.buffer; }
    /**
     * 获取当前文件的目标文本内容。
     */
    get destContent() { return this.content; }
    /**
     * 当前文件的最终保存二进制内容。
     */
    get buffer() {
        if (this._destBuffer != undefined) {
            return this._destBuffer;
        }
        if (this._destContent != undefined) {
            return this._destBuffer = encode_1.stringToBuffer(this._destContent, this.encoding);
        }
        return this.srcBuffer;
    }
    set buffer(value) {
        this._destBuffer = value;
        delete this._destContent;
        this.setModified();
    }
    /**
     * 当前文件的最终保存文本内容。
     */
    get content() {
        if (this._destContent != undefined) {
            return this._destContent;
        }
        if (this._destBuffer != undefined) {
            return this._destContent = encode_1.bufferToString(this._destBuffer, this.encoding);
        }
        return this.srcContent;
    }
    set content(value) {
        this._destContent = value;
        delete this._destBuffer;
        this.setModified();
    }
    /**
     * 当前文件的最终内容。
     */
    get data() { return this._destContent != undefined ? this._destContent : this.buffer; }
    set data(value) {
        if (typeof value === "string") {
            this.content = value;
        }
        else {
            this.buffer = value;
        }
    }
    /**
     * 判断当前文件是否已修改。
     */
    get modified() { return this._destContent != undefined || this._destBuffer != undefined; }
    /**
     * 读写当前文件使用的编码。
     */
    get encoding() { return exports.encoding; }
    set encoding(value) { lang_1.setProperty(this, "encoding", value); }
    /**
     * 标记当前文件已被修改。
     */
    setModified() { delete this.index; }
    /**
     * 计算指定索引对应的行列号。
     * @param index 要检查的索引。
     * @return 返回对应的行列号。
     */
    indexToLocation(index) { return location_1.indexToLocation(this.content, index, this.index || (this.index = [])); }
    /**
     * 计算指定行列号对应的索引。
     * @param location 要检查的行列号。
     * @return 返回对应的索引。
     */
    locationToIndex(location) { return location_1.locationToIndex(this.content, location, this.index || (this.index = [])); }
    // #endregion
    // #region 源映射
    /**
     * 当前文件是否需要生成源映射。
     */
    get sourceMap() { return exports.sourceMap; }
    set sourceMap(value) { lang_1.setProperty(this, "sourceMap", value); }
    /**
     * 当前文件的源映射保存路径。
     */
    get sourceMapPath() { return exports.sourceMapPath ? exports.sourceMapPath(this) : this.destPath + ".map"; }
    set sourceMapPath(value) { lang_1.setProperty(this, "sourceMapPath", value); }
    /**
     * 当前文件的源映射保存文件夹。
     */
    get sourceMapDir() { return path_1.getDir(this.sourceMapPath); }
    set sourceMapDir(value) { this.sourceMapPath = path_1.setDir(this.sourceMapPath, value); }
    /**
     * 是否在源文件插入 #SourceMappingURL。
     */
    get sourceMapEmit() { return typeof exports.sourceMapEmit === "function" ? exports.sourceMapEmit(this) : exports.sourceMapEmit; }
    set sourceMapEmit(value) { lang_1.setProperty(this, "sourceMapEmit", value); }
    /**
     * 是否内联源映射到源文件。
     * @desc 仅当 sourceMapEmit 为 true 时有效。
     */
    get sourceMapInline() { return typeof exports.sourceMapInline === "function" ? exports.sourceMapInline(this) : exports.sourceMapInline; }
    set sourceMapInline(value) { lang_1.setProperty(this, "sourceMapInline", value); }
    /**
     * 在源文件引用源映射的地址。
     * @desc 仅当 sourceMapEmit 为 true 时有效。
     */
    get sourceMapUrl() { return exports.sourceMapUrl ? exports.sourceMapUrl(this) : path_1.relativePath(this.destDir, this.sourceMapPath); }
    set sourceMapUrl(value) { lang_1.setProperty(this, "sourceMapUrl", value); }
    /**
     * 是否在源映射插入 file 段。
     */
    get sourceMapIncludeFile() { return typeof exports.sourceMapIncludeFile === "function" ? exports.sourceMapIncludeFile(this) : exports.sourceMapIncludeFile; }
    set sourceMapIncludeFile(value) { lang_1.setProperty(this, "sourceMapIncludeFile", value); }
    /**
     * 源映射中的 sourceRoot 内容。
     */
    get sourceMapRoot() { return typeof exports.sourceMapRoot === "function" ? exports.sourceMapRoot(this) : exports.sourceMapRoot; }
    set sourceMapRoot(value) { lang_1.setProperty(this, "sourceMapRoot", value); }
    /**
     * 是否在源映射插入 sourcesContent 段。
     */
    get sourceMapIncludeSourcesContent() { return typeof exports.sourceMapIncludeSourcesContent === "function" ? exports.sourceMapIncludeSourcesContent(this) : exports.sourceMapIncludeSourcesContent; }
    set sourceMapIncludeSourcesContent(value) { lang_1.setProperty(this, "sourceMapIncludeSourcesContent", value); }
    /**
     * 是否在源映射插入 names 段。
     */
    get sourceMapIncludeNames() { return typeof exports.sourceMapIncludeNames === "function" ? exports.sourceMapIncludeNames(this) : exports.sourceMapIncludeNames; }
    set sourceMapIncludeNames(value) { lang_1.setProperty(this, "sourceMapIncludeNames", value); }
    /**
     * 获取当前文件的源映射构建器。
     * @return 返回源映射对象。如果不存在则返回 undefined。
     */
    get sourceMapBuilder() {
        if (!this.sourceMapData) {
            return;
        }
        const sourceMapBuilder = sourceMap_1.toSourceMapBuilder(this.sourceMapData);
        sourceMapBuilder.file = this.srcPath;
        return this.sourceMapData = sourceMapBuilder;
    }
    /**
     * 当前文件的源映射对象。
     */
    get sourceMapObject() {
        if (!this.sourceMapData) {
            return;
        }
        this.sourceMapData = sourceMap_1.toSourceMapObject(this.sourceMapData);
        if (!this.sourceMapData.sources || !this.sourceMapData.mappings) {
            return;
        }
        this.sourceMapData.file = this.srcPath;
        return this.sourceMapData;
    }
    set sourceMapObject(value) {
        this.sourceMapData = value;
    }
    /**
     * 当前文件的源映射字符串。
     */
    get sourceMapString() { return JSON.stringify(this.sourceMapObject); }
    set sourceMapString(value) {
        this.sourceMapData = value;
    }
    /**
     * 合并指定的源映射。如果当前文件已经存在源映射则进行合并。
     * @param sourceMapData 要应用的源映射。
     */
    applySourceMap(sourceMapData) {
        if (sourceMapData) {
            const sourceMapBuilder = this.sourceMapBuilder;
            if (sourceMapBuilder) {
                (this.sourceMapData = sourceMap_1.toSourceMapBuilder(sourceMapData)).applySourceMap(sourceMapBuilder);
            }
            else {
                this.sourceMapData = sourceMapData;
            }
        }
    }
    /**
     * 获取当前文件的最终源映射。
     * @return 返回源映射对象。如果不存在则返回 undefined。
     */
    getSourceMap() {
        if (!this.sourceMapData) {
            return;
        }
        const sourceMapObject = sourceMap_1.toSourceMapObject(this.sourceMapData);
        // 生成最终的 sourceMap 数据。
        const result = {
            version: sourceMapObject.version || 3
        };
        // file。
        if (this.sourceMapIncludeFile) {
            result.file = path_1.relativePath(path_1.getDir(this.sourceMapPath), this.destPath);
        }
        // sourceRoot。
        const sourceRoot = this.sourceMapRoot || sourceMapObject.sourceRoot;
        if (sourceRoot) {
            result.sourceRoot = sourceRoot;
        }
        // sources。
        if (sourceMapObject.sources) {
            result.sources = [];
            for (let i = 0; i < sourceMapObject.sources.length; i++) {
                result.sources[i] = exports.sourceMapSource ?
                    exports.sourceMapSource(sourceMapObject.sources[i], this) :
                    sourceRoot ?
                        sourceRoot === "file:///" ?
                            path_1.normalizePath(sourceMapObject.sources[i]) :
                            path_1.relativePath(sourceMapObject.sources[i]) :
                        path_1.relativePath(this.sourceMapDir, sourceMapObject.sources[i]);
            }
            // sourcesContent。
            if (this.sourceMapIncludeSourcesContent) {
                result.sourcesContent = [];
                for (let i = 0; i < sourceMapObject.sources.length; i++) {
                    if (exports.sourceMapSourceContent) {
                        result.sourcesContent[i] = exports.sourceMapSourceContent(sourceMapObject.sources[i], this);
                    }
                    else {
                        const sourcesContent = sourceMapObject.sourcesContent && sourceMapObject.sourcesContent[i];
                        if (sourcesContent) {
                            result.sourcesContent[i] = sourcesContent;
                        }
                        else if (sourceMapObject.sources[i] === this.initialPath) {
                            result.sourcesContent[i] = this.srcContent;
                        }
                        else {
                            const task = progress_1.begin("Reading {file}(from source map)", { file: sourceMapObject.sources[i] });
                            try {
                                result.sourcesContent[i] = encode_1.bufferToString(fs_1.readFile(sourceMapObject.sources[i]), exports.encoding);
                            }
                            catch (e) {
                                result.sourcesContent[i] = `Error: Cannot read '${sourceMapObject.sources[i]}'`;
                            }
                            finally {
                                progress_1.end(task);
                            }
                        }
                    }
                }
            }
        }
        // names。
        if (this.sourceMapIncludeNames && sourceMapObject.names && sourceMapObject.names.length) {
            result.names = sourceMapObject.names;
        }
        // mappings。
        result.mappings = sourceMapObject.mappings || "";
        // 验证源映射。
        if (exports.onSourceMapValidate) {
            exports.onSourceMapValidate(result, this);
        }
        return result;
    }
    /**
     * 判断当前文件是否已载入。
     */
    get loaded() {
        return !this.initialPath || this._destContent != undefined || this._destBuffer != undefined || this._srcBuffer != undefined || this._srcContent != undefined || this.buildMode === 1 /* clean */;
    }
    /**
     * 载入当前文件内容。
     * @param callback 异步操作完成后的回调函数。
     */
    load(callback) {
        if (this.loaded) {
            callback && callback(null, this);
        }
        else {
            const task = progress_1.begin("Reading: {file}", { file: this.toString() });
            fs_1.readFile(this.initialPath, (error, data) => {
                if (error) {
                    this.error({
                        error: error,
                        showStack: false
                    });
                }
                progress_1.end(task);
                this._srcBuffer = data || Buffer.allocUnsafe(0);
                callback && callback(error, this);
            });
        }
    }
    /**
     * 保存当前文件到指定路径。
     * @param dir 要保存的目标文件夹路径。如果为空则保存到当前文件夹。
     * @param callback 异步操作完成后的回调函数。
     */
    save(dir, callback) {
        // 更新基路径。
        if (dir != undefined) {
            this.base = path_1.resolvePath(dir);
        }
        // 验证文件。
        if (exports.onFileValidate && exports.onFileValidate(this) === false) {
            callback && callback(null, this);
            return;
        }
        // 验证路径。
        const savePath = this.path;
        if (savePath == undefined) {
            callback && callback(null, this);
            return;
        }
        const sourceMapEmit = this.sourceMap && this.sourceMapData && this.sourceMapEmit;
        const modified = this.modified || sourceMapEmit;
        if (this.initialPath && path_1.pathEquals(this.initialPath, savePath)) {
            // 文件未修改，跳过保存。
            if (!modified) {
                callback && callback(null, this);
                return;
            }
            // 不允许覆盖源文件。
            if (!this.overwrite) {
                this.error("Cannot overwrite source files. Use '--overwrite' to force saving.");
                callback && callback(null, this);
                return;
            }
        }
        const sourceMapPath = this.sourceMap && this.sourceMapData && !this.sourceMapInline && this.sourceMapPath;
        if (exports.saveFile) {
            if (sourceMapPath) {
                exports.saveFile(sourceMapPath, this.buildMode === 1 /* clean */ ? null : encode_1.stringToBuffer(JSON.stringify(this.getSourceMap())));
            }
            if (this.buildMode === 1 /* clean */) {
                exports.saveFile(savePath, null);
            }
            else if (sourceMapEmit) {
                exports.saveFile(savePath, encode_1.stringToBuffer(sourceMap_1.appendSourceMapUrl(this.content, this.sourceMapInline ? encode_1.base64Uri("application/json", JSON.stringify(this.getSourceMap())) : this.sourceMapUrl, /\.js$/i.test(this.name))));
                callback && callback(null, this);
            }
            else if (this.loaded) {
                exports.saveFile(savePath, this.buffer);
                callback && callback(null, this);
            }
            else {
                this.load(error => {
                    if (!error) {
                        exports.saveFile(savePath, this.buffer);
                    }
                    callback && callback(error, this);
                });
            }
        }
        else {
            let task;
            const args = { file: this };
            let firstError;
            let pending = 1;
            const done = (error) => {
                if (error) {
                    this.error({
                        showStack: false,
                        error: error
                    });
                }
                firstError = firstError || error;
                if (--pending < 1) {
                    progress_1.end(task);
                    if (!firstError) {
                        exports.fileCount++;
                        if (exports.onFileSave) {
                            exports.onFileSave(this);
                        }
                    }
                    callback && callback(firstError, this);
                }
            };
            switch (this.buildMode) {
                // 生成文件。
                case 0 /* build */:
                case 3 /* watch */:
                case 4 /* server */:
                    if (sourceMapEmit) {
                        task = progress_1.begin("Writing: {file}", args);
                        fs_1.writeFile(savePath, encode_1.stringToBuffer(sourceMap_1.appendSourceMapUrl(this.content, this.sourceMapInline ? encode_1.base64Uri("application/json", JSON.stringify(this.getSourceMap())) : this.sourceMapUrl, /\.js$/i.test(this.name)), this.encoding), done);
                    }
                    else {
                        task = progress_1.begin(modified ? "Writing: {file}" : "Copying: {file}", args);
                        if (this.loaded) {
                            fs_1.writeFile(savePath, this.buffer, done);
                        }
                        else {
                            fs_1.copyFile(this.initialPath, savePath, done);
                        }
                    }
                    if (sourceMapPath) {
                        pending++;
                        fs_1.writeFile(sourceMapPath, JSON.stringify(this.getSourceMap()), done);
                    }
                    break;
                // 清理文件。
                case 1 /* clean */:
                    task = progress_1.begin("Cleaning: {file}", args);
                    fs_1.deleteFile(savePath, error => {
                        if (error) {
                            done(error.code === "EPERM" ? null : error);
                        }
                        else {
                            fs_1.deleteParentDirIfEmpty(savePath, done);
                        }
                    });
                    if (sourceMapPath) {
                        pending++;
                        fs_1.deleteFile(sourceMapPath, error => {
                            if (error) {
                                done(error.code === "EPERM" ? null : error);
                            }
                            else {
                                fs_1.deleteParentDirIfEmpty(sourceMapPath, done);
                            }
                        });
                    }
                    break;
                // 预览文件。
                default:
                    task = progress_1.begin("(Preview)Writing: {file}", args);
                    done(null);
                    break;
            }
        }
    }
    /**
     * 删除当前源文件。
     * @param deleteDir 是否删除空的父文件夹。
     * @param callback 异步操作完成后的回调函数。
     */
    delete(deleteDir = true, callback) {
        // 验证路径。
        if (!this.initialPath) {
            callback && callback(null, this);
            return;
        }
        // 如果删除了源文件则允许覆盖写入。
        this.overwrite = true;
        let taskId;
        const args = { file: this.toString() };
        const done = (error) => {
            if (error) {
                this.error({
                    error: error,
                    showStack: false
                });
            }
            progress_1.end(taskId);
            if (!error) {
                exports.fileCount++;
                if (exports.onFileDelete) {
                    exports.onFileDelete(this);
                }
            }
            callback && callback(error, this);
        };
        // 预览模式不写入硬盘。
        if (this.buildMode === 2 /* preview */) {
            taskId = progress_1.begin("(Preview)Deleting: {file}", args);
            done(null);
            return;
        }
        // 删除文件。
        taskId = progress_1.begin("Deleting: {file}", args);
        fs_1.deleteFile(this.initialPath, error => {
            if (error) {
                done(error);
            }
            else if (deleteDir !== false) {
                fs_1.deleteParentDirIfEmpty(this.initialPath, done);
            }
            else {
                done(null);
            }
        });
    }
    /**
     * 是否允许覆盖源文件。
     */
    get overwrite() { return exports.overwrite; }
    set overwrite(value) { lang_1.setProperty(this, "overwrite", value); }
    /**
     * 记录一条和当前文件相关的日志。
     * @param data 要记录的日志数据。
     * @param args 格式化参数。日志信息中 `{x}` 会被替换为 `args.x` 的值。
     * @param level 要记录的日志等级。
     */
    log(data, args, level = 1 /* log */) {
        if (!(data instanceof logging_1.LogEntry)) {
            data = new FileLogEntry(this, data, args);
        }
        if (exports.onFileLog && exports.onFileLog(this, data, level) === false) {
            return;
        }
        switch (level) {
            case 4 /* error */:
            case 5 /* fatal */:
                this.errorCount++;
                break;
            case 3 /* warning */:
                this.warningCount++;
                break;
        }
        logging_1.log(data, undefined, level);
    }
    /**
     * 记录生成当前文件时出现的错误。
     * @param data 要记录的日志数据。
     * @param args 格式化参数。日志信息中 `{x}` 会被替换为 `args.x` 的值。
     */
    error(data, args) { this.log(data, args, 4 /* error */); }
    /**
     * 记录生成当前文件时出现的警告。
     * @param data 要记录的日志数据。
     * @param args 格式化参数。日志信息中 `{x}` 会被替换为 `args.x` 的值。
     */
    warning(data, args) { this.log(data, args, 3 /* warning */); }
    /**
     * 记录生成当前文件时的详细信息。
     * @param data 要记录的日志数据。
     * @param args 格式化参数。日志信息中 `{x}` 会被替换为 `args.x` 的值。
     */
    verbose(data, args) { this.log(data, args, 0 /* verbose */); }
    /**
     * 添加当前文件的依赖项。
     * @param path 相关的路径。
     * @param source 当前依赖的来源。
     */
    dep(path, source) {
        if (Array.isArray(path)) {
            for (const p of path) {
                this.dep(p, source);
            }
        }
        else {
            path = path_1.resolvePath(path);
            if (exports.onFileDep && exports.onFileDep(this, path, source) === false) {
                return;
            }
            this.deps = this.deps || [];
            this.deps.push(path);
        }
    }
    /**
     * 添加当前文件的引用项。
     * @param path 相关的路径。
     * @param source 当前引用的来源。
     */
    ref(path, source) {
        if (Array.isArray(path)) {
            for (const p of path) {
                this.ref(p, source);
            }
        }
        else {
            path = path_1.resolvePath(path);
            if (exports.onFileRef && exports.onFileRef(this, path, source) === false) {
                return;
            }
            this.refs = this.refs || [];
            this.refs.push(path);
        }
    }
    // #endregion
    // #region 工具
    /**
     * 创建一个文本写入器。
     * @param options 写入器的配置。
     * @return 返回一个写入器。
     */
    createWriter(options) {
        return (options && options.sourceMap != undefined ? options.sourceMap : this.sourceMap) ? new writer_1.SourceMapWriter(this, options) : new writer_1.Writer(this, options);
    }
    /**
     * 创建一个二进制写入流。
     * @param options 写入流的配置。
     * @return 返回一个写入流。
     */
    createStream(options) {
        return new writer_1.BufferStream(this, options);
    }
    /**
     * 创建当前文件的副本。
     * @return 返回新文件对象。
     */
    clone() {
        const result = {
            __proto__: this.__proto__
        };
        for (const key in this) {
            if (this.hasOwnProperty(key)) {
                let value = this[key];
                if (value instanceof Buffer) {
                    value = new Buffer(value.length);
                    this[key].copy(value);
                }
                else if (Array.isArray(value)) {
                    value = value.slice(0);
                }
                result[key] = value;
            }
        }
        return result;
    }
    /**
     * 判断当前文件是否实际存在。
     */
    get exists() { return this.initialPath ? fs_1.existsFile(this.initialPath) : false; }
    /**
     * 获取当前文件的属性对象。
     */
    get stats() { return this.initialPath ? fs_1.getStat(this.initialPath) : null; }
    /**
     * 测试当前文件名是否匹配指定的匹配器。
     * @param matcher 要测试通配符、正则表达式、函数或以上的匹配器组成的数组。
     * @return 如果匹配则返回 true，否则返回 false。
     */
    test(matcher) { return matcher_1.Matcher.test(this.destPath, matcher); }
    /**
     * 解析当前文件内的地址所表示的实际地址。
     * @param url 要解析的地址。如 `../a.js?a=1`。
     * @return 返回解析好的绝对地址。
     */
    resolve(url) { return path_1.resolvePath(this.srcDir, url); }
    /**
     * 获取在当前文件内引用指定地址或文件所使用的相对地址。
     * @param url 要解析的地址或文件。
     * @return 返回解析好的相对地址。
     */
    relative(url) { return path_1.relativePath(this.destDir, url instanceof File ? url.destPath : url); }
}
exports.File = File;
/**
 * 表示生成模式。
 */
var BuildMode;
(function (BuildMode) {
    /**
     * 生成模式。
     */
    BuildMode[BuildMode["build"] = 0] = "build";
    /**
     * 清理模式。
     */
    BuildMode[BuildMode["clean"] = 1] = "clean";
    /**
     * 预览模式。
     */
    BuildMode[BuildMode["preview"] = 2] = "preview";
    /**
     * 监听模式。
     */
    BuildMode[BuildMode["watch"] = 3] = "watch";
    /**
     * 服务器模式。
     */
    BuildMode[BuildMode["server"] = 4] = "server";
})(BuildMode = exports.BuildMode || (exports.BuildMode = {}));
/**
 * 文件的生成模式。
 */
exports.buildMode = 0 /* build */;
/**
 * 读写文件使用的默认编码。
 */
exports.encoding = "utf-8";
/**
 * 是否允许覆盖源文件。
 */
exports.overwrite = false;
/**
 * 是否启用源映射。
 */
exports.sourceMap = false;
/**
 * 用于计算每个文件的源映射路径的回调函数。
 * @param file 当前相关的文件。
 * @return 返回源映射的绝对路径。
 */
exports.sourceMapPath = null;
/**
 * 用于计算每个文件的源映射地址的回调函数。
 * @param file 当前相关的文件。
 * @return 返回源映射地址。
 */
exports.sourceMapUrl = null;
/**
 * 用于计算源映射中指定源文件地址的回调函数。
 * @param source 要计算的源文件地址。
 * @param file 当前相关的文件。
 * @return 返回对应的源文件地址。
 */
exports.sourceMapSource = null;
/**
 * 用于计算源映射中指定源文件内容的回调函数。
 * @param source 要计算的源文件地址。
 * @param file 当前相关的文件。
 * @return 返回对应的源文件内容。
 */
exports.sourceMapSourceContent = null;
/**
 * 是否在源文件中内联源映射。
 */
exports.sourceMapInline = false;
/**
 * 是否在源文件追加对源映射的引用注释。
 */
exports.sourceMapEmit = true;
/**
 * 源映射中引用源的跟地址。
 */
exports.sourceMapRoot = "";
/**
 * 是否在源映射插入 sourcesContent 段。
 */
exports.sourceMapIncludeSourcesContent = false;
/**
 * 是否在源映射插入 file 段。
 */
exports.sourceMapIncludeFile = true;
/**
 * 是否在源映射插入 names 段。
 */
exports.sourceMapIncludeNames = true;
/**
 * 生成文件源映射的回调函数。
 * @param sourceMap 当前的源映射对象。
 * @param file 当前相关的文件。
 */
exports.onSourceMapValidate = (sourceMap, file) => { events_1.emit("sourceMapValidate", sourceMap, file); };
/**
 * 即将保存文件时的回调函数。
 * @param file 当前相关的文件。
 * @return 如果函数返回 false，则不保存此文件。
 */
exports.onFileValidate = (file) => { events_1.emit("fileValidate", file); };
/**
 * 保存文件后的回调函数。
 * @param file 当前相关的文件。
 */
exports.onFileSave = (file) => { events_1.emit("fileSave", file); };
/**
 * 当删除文件后的回调函数。
 * @param file 当前相关的文件。
 */
exports.onFileDelete = (file) => { events_1.emit("fileDelete", file); };
/**
 * 自定义写入文件的方法。
 * @param path 当前写入的文件路径。
 * @param buffer 当前写入的文件内容。如果为 null 表示需删除文件。
 */
exports.saveFile = null;
/**
 * 获取已处理的文件数。
 */
exports.fileCount = 0;
/**
 * 是否允许系统使用源映射信息。
 */
exports.evalSourceMap = true;
/**
 * 表示处理文件时产生的日志项。
 */
class FileLogEntry extends logging_1.LogEntry {
    /**
     * 初始化新的日志项。
     * @param file 源文件对象。
     * @param data 要处理的日志数据。
     * @param args 格式化参数。日志信息中 `{x}` 会被替换为 `args.x` 的值。
     */
    constructor(file, data, args) {
        super(data, args);
        // 统一文件对象。
        if (!this.file) {
            this.file = this.fileName != undefined && file.initialPath && !path_1.pathEquals(this.fileName, file.initialPath) ? new File(this.fileName, file.base) : file;
        }
        // 执行源映射：找到真正的位置。
        let fromSource = false;
        if (this.file.sourceMapData && exports.evalSourceMap && this.evalSourceMap !== false && this.line != undefined) {
            fromSource = true;
            const sourceMapBuilder = this.file.sourceMapBuilder;
            const startSource = sourceMapBuilder.getSource(this.line, this.column || 0, false, true);
            if (startSource && startSource.sourcePath != undefined) {
                if (!this.file.initialPath || !path_1.pathEquals(this.file.initialPath, startSource.sourcePath)) {
                    this.file = new File(startSource.sourcePath, file.base);
                }
                this.line = startSource.line;
                this.column = startSource.column;
                if (this.endLine != undefined) {
                    const endSource = sourceMapBuilder.getSource(this.endLine, this.endColumn || 0, false, true);
                    if (endSource && endSource.sourcePath != undefined && path_1.pathEquals(startSource.sourcePath, endSource.sourcePath)) {
                        this.endLine = endSource.line;
                        this.endColumn = endSource.column;
                    }
                    else {
                        delete this.endLine;
                        delete this.endColumn;
                    }
                }
            }
        }
        // 从文件提取信息。
        this.fileName = this.file.srcPath;
        if (this.content === undefined && this.line != undefined) {
            this.content = fromSource ? this.file.srcContent : this.file.content;
        }
    }
}
exports.FileLogEntry = FileLogEntry;
/**
 * 处理文件时产生日志的回调函数。
 * @param log 要记录的日志项。
 * @param level 要记录的日志等级。
 * @param file 当前正在生成的文件。
 * @return 如果函数返回 false，则忽略当前日志。
 */
exports.onFileLog = (file, log, level) => { events_1.emit("fileLog", file, log, level); };
/**
 * 处理文件时发现依赖的回调函数。
 * @param file 当前正在生成的文件。
 * @param path 要依赖的文件路径。
 * @param source 要依赖的文件路径。
 * @return 如果函数返回 false，则忽略当前依赖。
 */
exports.onFileDep = (file, path, source) => { events_1.emit("fileDep", file, path, source); };
/**
 * 处理文件时发现引用的回调函数。
 * @param file 当前正在生成的文件。
 * @param path 要引用的文件路径。
 * @param source 要引用的文件路径。
 * @return 如果函数返回 false，则忽略当前引用。
 */
exports.onFileRef = (file, path, source) => { events_1.emit("fileRef", file, path, source); };
