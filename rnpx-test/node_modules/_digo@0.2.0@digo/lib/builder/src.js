"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const glob_1 = require("../utility/glob");
const matcher_1 = require("../utility/matcher");
const path_1 = require("../utility/path");
const async_1 = require("./async");
const events_1 = require("./events");
const file_1 = require("./file");
const fileList_1 = require("./fileList");
const logging_1 = require("./logging");
/**
 * 全局匹配器。
 */
exports.globalMatcher = new matcher_1.Matcher();
/**
 * 表示一个根文件列表。
 */
class RootFileList extends fileList_1.FileList {
    constructor() {
        super(...arguments);
        /**
         * 当前列表的根匹配器。
         */
        this.matcher = new matcher_1.Matcher();
        /**
         * 是否已锁定。
         */
        this._locked = false;
    }
    /**
     * 创建属于当前列表的文件。
     * @param path 要添加的文件对象。
     * @return 返回新建的文件对象。
     */
    createFile(path) {
        const base = this.matcher.base;
        return new file_1.File(path, path_1.pathEquals(path, base) ? path_1.getDir(base) : base);
    }
    /**
     * 当作为顶级列表时表示所有子列表执行完成后的回调。
     */
    done() {
        if (this._locked) {
            this._locked = false;
            async_1.asyncQueue.unlock("RootFileList");
        }
    }
    /**
     * 向当前列表添加一个文件。
     * @param file 要添加的文件。
     * @param root 文件所属的根列表。
     */
    add(file, root) {
        if (!this._locked) {
            this._locked = true;
            async_1.asyncQueue.lock("RootFileList");
        }
        super.add(file, root);
    }
    /**
     * 通知当前列表所有文件已添加。
     */
    end() {
        if (!this._locked) {
            this._locked = true;
            async_1.asyncQueue.lock("RootFileList");
        }
        super.end();
    }
}
exports.RootFileList = RootFileList;
/**
 * 筛选指定的文件并返回一个文件列表。
 * @param patterns 用于筛选文件的通配符、正则表达式、函数或以上组合的数组。
 * @return 返回一个文件列表对象。
 */
function src(...patterns) {
    const result = new RootFileList();
    let pending = 1;
    async_1.asyncQueue.lock("src");
    const done = () => {
        if (--pending < 1) {
            result.end();
            async_1.asyncQueue.unlock("src");
        }
    };
    for (const pattern of patterns) {
        if (pattern instanceof fileList_1.FileList) {
            pending++;
            pattern.pipe({
                collect: false,
                add(file) {
                    result.add(file);
                },
                end: done
            });
        }
        else if (pattern instanceof file_1.File) {
            pending++;
            process.nextTick(() => {
                result.add(pattern);
                done();
            });
        }
        else {
            result.matcher.add(pattern);
        }
    }
    if (result.matcher.patterns.length) {
        glob_1.glob(result.matcher, {
            globalMatcher: exports.globalMatcher,
            error: logging_1.verbose,
            ignored(path, global) {
                logging_1.verbose(global ? "Ignoring globally: {path}" : "Ignoring: {path}", { path: logging_1.getDisplayName(path) });
            },
            walk(path, stats, entries) {
                events_1.emit("addDir", path, stats, entries);
            },
            file(path, stats) {
                result.add(result.createFile(path));
                events_1.emit("addFile", path, stats);
            },
            end: done
        });
        events_1.emit("addList", result);
    }
    else {
        done();
    }
    return result;
}
exports.src = src;
