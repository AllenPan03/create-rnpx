"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const childProcess = require("child_process");
const encode_1 = require("../utility/encode");
const async_1 = require("./async");
const logging_1 = require("./logging");
const progress_1 = require("./progress");
function exec(command, options = {}, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    }
    if (options.shell == undefined) {
        options.shell = true;
    }
    // 修复 Windows 上编码问题。
    let file = command;
    let args = options.args;
    let needDetectEncoding = false;
    if (process.platform === "win32" && options.shell === true) {
        file = process.env.comspec || "cmd.exe";
        args = ["/u", "/d", "/s", "/c", '"' + command + (args ? " " + args.join(" ") : "") + '"'];
        options.shell = false;
        options.windowsVerbatimArguments = true;
        needDetectEncoding = true;
    }
    if (!options.encoding) {
        // 设置为 null 表示返回缓存本身。
        // https://github.com/nodejs/node/issues/6930
        options.encoding = null;
    }
    if (options.cwd) {
        const relative = digo.relativePath(options.cwd);
        if (relative !== ".") {
            command = `${relative}>${command}`;
        }
    }
    const report = (code, e, stdout, stderr) => {
        if (options.slient !== true) {
            if (stdout) {
                logging_1.log(stdout);
            }
            if (stderr) {
                logging_1.info(stderr);
            }
            if (code !== 0) {
                logging_1.error("Command '{command}' exited with code {bright:code}.", { command: command, code: code });
            }
        }
    };
    const task = progress_1.begin(command);
    if (typeof callback === "function") {
        async_1.asyncQueue.lock(task);
        return childProcess.execFile(file, args || [], options, (e, stdout, stderr) => {
            progress_1.end(task);
            const code = e ? e.code : 0;
            stdout = toString(stdout, needDetectEncoding);
            stderr = toString(stderr, needDetectEncoding);
            report(code, e, stdout, stderr);
            callback(code, stdout, stderr);
            async_1.asyncQueue.unlock(task);
        });
    }
    else {
        const spawnResult = childProcess.spawnSync(file, args || [], options);
        progress_1.end(task);
        spawnResult.stdout = toString(spawnResult.stdout, needDetectEncoding);
        spawnResult.stderr = toString(spawnResult.stderr, needDetectEncoding);
        report(spawnResult.status, spawnResult.error, spawnResult.stdout, spawnResult.stderr);
        return spawnResult;
    }
}
exports.exec = exec;
function toString(buffer, needDetectEncoding) {
    if (buffer instanceof Buffer) {
        buffer = encode_1.bufferToString(buffer, needDetectEncoding ? detectEncoding(buffer) : undefined);
    }
    return buffer ? buffer.replace(/(?:\r\n|\r|\n)$/, "") : "";
}
function detectEncoding(buffer) {
    for (let i = 1; i < buffer.length; i += 2) {
        if (buffer[i] === 0) {
            return "utf16le";
        }
    }
    return "utf8";
}
